#XXX pre-make   gcs?

#
# incinstall_${Package} - target to install include files for this package
#   This includes generating code.
#


# gcb = gc-$(Package).c
# gch = gc-$(Package).h
#
# bproto_$(Package) : $(gcb) $(gch)
#    bproto   # create files in other directories as well
#
# $(Package)_gen.h : $(GenTargets)     # targets from other packages
#        cat $(GenInc) > $@
#
#
#
#
# incinstall_$(Package) : $(Package)_gen.h
#
#

#
# do-proto - flag if proto should be run
# GSrcs    - generated source files for TGTLib
# GenInc   - generated include files
# hdrf     - 
#

# list of file dependencies for incinstall_${Package} target
# this includes header files to install in IncDir and
#  # source and headers generated by bproto
set(TGTInc_LIST)


#
# language bindings
#
## XXX make-macros  generate target
## XXX premake -- IncAction = @pact generate
## XXX generate : ${gcb} ${hdrf}
if(do-bproto)
    set(gcb ${CMAKE_CURRENT_BINARY_DIR}/gc-${Package}.c)
    set(ghb ${CMAKE_CURRENT_BINARY_DIR}/gc-${Package}.h)

# bproto creates source in several packages.
# However, it seems CMake cannot track that so this variable is unused.
# Instead use the bproto-${Package} targets
    set(bproto-output
        ${CMAKE_CURRENT_BINARY_DIR}/gc-${Package}.c
        ${CMAKE_CURRENT_BINARY_DIR}/gc-${Package}.h
#        ${PSY_build}/${Package}/gc-${Package}.c
#        ${PSY_build}/${Package}/gc-${Package}.h
        ${PSY_build}/fortran/gf-${Package}.c
        ${PSY_build}/fortran/gm-${Package}.f
        ${PSY_build}/sx/gs-${Package}.c
        ${PSY_build}/sx/gs-${Package}.h
        ${PSY_build}/python/gp-${Package}.c
        ${PSY_build}/python/gp-${Package}.h
        ${PSY_build}/html/gh-${Package}.html
    )
# But, as I already mentioned, be careful to mark the files as GENERATED and
# add them to the ADDITIONAL_MAKE_CLEAN_FILES directory property. One caveat
    foreach(file)
        SET_SOURCE_FILES_PROPERTIES(${file}  PROPERTIES GENERATED TRUE)
    endforeach(file)
#  SET_SOURCE_FILES_PROPERTIES(${gcb} PROPERTIES GENERATED TRUE)

#    LIST(APPEND GSrcs ${gcb})

    LIST(APPEND GenInc ${ghb})
    LIST(APPEND hdrf ${ghb})

    # Assume all source, unless a specific set of sources
    # have been defined in bproto-Srcs
    if ("${bproto-Srcs}" STREQUAL "")
        set(bproto-Srcs ${Srcs})
    endif()

    # Add target used by other directories to call bproto
    add_custom_command(
        OUTPUT ${gcb} ${ghb}
#        OUTPUT ${bproto-output}
        DEPENDS bproto
        COMMAND ${BinDir}/bproto
               -d ${CMAKE_CURRENT_BINARY_DIR}
               -move
               ${ExcludeType}
#              -f ${bproto-Srcs}
               # do not pass header files to bproto
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        COMMENT "bproto ${Package}"
    )
    # Add target used by other directories to call bproto
    add_custom_target(
        bproto-${Package}
#        ALL
        DEPENDS ${gcb} ${ghb}
    )

#    LIST(APPEND TGTInc_LIST ${gcb} ${ghb})

endif()

#--${IncDir}/score_gen.h : ${GenInc}
#--	@echo "build score_gen.h"
#--	@rm -f ${IncDir}/score_gen.h
#--	@cat ${GenInc} > ${IncDir}/score_gen.h
#
# GenInc is list of files to merge
# GenTargets is list targets required to build GenInc
# These targets will generate code in other packages.
#
if(GenInc)
    add_custom_command(
        OUTPUT ${IncDir}/${Package}_gen.h
#        DEPENDS ${GenInc}
        DEPENDS ${ghb} ${GenTargets}
        COMMAND rm -f ${IncDir}/${Package}_gen.h
        COMMAND cat ${GenInc} > ${IncDir}/${Package}_gen.h
        COMMENT "build ${Package}_gen.h"
    )
    LIST(APPEND hdrf ${IncDir}/${Package}_gen.h)

#    set_source_files_properties(
#        ${GenInc} PROPERTIES GENERATED TRUE
#    )

endif()

if(hdrf)
    add_custom_target(generate_${Package}
        DEPENDS ${hdrf}
    )
    set_property(GLOBAL APPEND PROPERTY generate_target generate_${Package})
endif()

#
# install includes
#
#--incinstall : ${TGTInc}
#--	@[ ! -f ${IncDir}/.lock ] || { echo "${IncDir} is locked" ; exit 1 ; }
#--	${IncAction}
#--	@[ "${TGTInc}" != "noinc" ] && { echo "sinstall ${TGTInc} ${IncDir}" ; sinstall ${TGTInc} ${IncDir} ; } || { exit 0 ; }

foreach(file ${TGTInc})
    set(infile  ${CMAKE_CURRENT_SOURCE_DIR}/${file})
    set(outfile ${IncDir}/${file})
    add_custom_command(
        OUTPUT ${outfile}
        COMMAND ${CMAKE_COMMAND} -E copy ${infile} ${outfile}
        MAIN_DEPENDENCY ${infile}
        COMMENT "Copy ${file}"
    )
    LIST(APPEND TGTInc_LIST ${outfile})
endforeach(file)

add_custom_target(incinstall_${Package}
#   noinc
    DEPENDS ${TGTInc_LIST}
    COMMENT "incinstall ${Package}"
)
set_property(GLOBAL APPEND PROPERTY incinstall_target incinstall_${Package})

if(hdrf)
    add_dependencies(incinstall_${Package} generate_${Package})
endif()


add_custom_target(devlib_${Package}
#   noinc
#    COMMAND ${PSY_ScrDir}/sinstall ${TGTInc} ${IncDir}
#    DEPENDS ${TGTInc}
#    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    COMMENT "devlib in ${Package}"
)
set_property(GLOBAL APPEND PROPERTY devlib_target devlib_${Package})

#
# make new library
#
#--${TGTLib} : ${LibDep}
#--	@[ ! -f ${LibDir}/.lock ] || { echo "${LibDir} is locked" ; exit 1 ; }
#--	${LibAction}
#--	aranlib ${TGTLib}
#--
#--devlib : ${TGTLib}
if(TGTLib)
    add_library(${TGTLib} ${GSrcs} ${Srcs})
#    add_dependencies(${TGTLib} incinstall_${Package})
    add_dependencies(${TGTLib} incinstall)
    add_dependencies(devlib_${Package} ${TGTLib})
endif()





# Add to global targets


#set(MY_GLOBAL_VARIABLE "Some value" CACHE STRING "Description")
#list(APPEND $pact_generate generate_${Package})
#set (SOURCEFILES main.cpp foo.cpp PARENT_SCOPE) 
