#!/bin/csh -f
#
# IMPORT-API - generate an API binding for a foreign package
#            - to be used by PACT and
#            - linked statically or dynamically as requested
#
# include "cpyright.h"
#

unalias *

set pact   = `which perdb`
set bindir = $pact:h
set lbase  = $bindir:h
set devinc = $lbase/include

if (-d ../scripts) then
   source ../scripts/env-csh
else
   source $lbase/etc/env-csh
endif

unset bindir
unset lbase

@ nerr  = 0
@ nwarn = 0

set api    = ""
set def    = ""
set fatal  = 0
set keep   = FALSE
set noinc  = FALSE
set incdir = ( . /usr/include )
set libdir = ( . /lib64 /usr/lib64 /lib /usr/lib )

while ($#argv > 0)
   switch ($1)
      case -f:
           set fatal = 1
           breaksw
      case -h:
           echo ""
           echo "Usage: import-api [-f] [-h] [-i] [-k] [-I<incdir>]* [-L<libdir>]* [-o <api>] <def>"
           echo "   f      make errors fatal (exit with 1 instead of 0)"
           echo "   h      this help message"
           echo "   i      do not expand dependent includes"
           echo "   k      keep prototypes file"
           echo "   I      add <incdir> to include directory list"
           echo "   L      add <libdir> to lib directory list"
           echo "   o      name of generated API file"
           echo "   <def>  api definition file"
           echo ""
           exit(1)
      case -i:
           set noinc = TRUE
           breaksw
      case -I*:
           set t = ( `echo $1 | sed 's|-I||g' | sed 's|:| |g'` )
           set incdir = ( $t $incdir )
           unset t
           breaksw
      case -k:
           set keep = TRUE
           breaksw
      case -L*:
           set t = ( `echo $1 | sed 's|-L||g' | sed 's|:| |g'` )
           set libdir = ( $t $libdir )
           unset t
           breaksw
      case -o:
           shift
           set api = $1
           breaksw
      default:
           set def = $1
           breaksw
   endsw
   shift
end

if ("$def" == "") then
   echo "No API definition file specified - exiting"
   exit($fatal)
endif
if (!(-f "$def")) then
   echo "File '$def' does not exist - exiting"
   exit($fatal)
endif

set pck = ( `grep -w package $def` )
set pck = $pck[2]
set PCK = `echo $pck | tr "[a-z]" "[A-Z]"`

set so = ( `grep -w so $def` )
set so = $so[2]
set ok = FALSE
foreach d ($libdir)
   if (-f $d/$so) then
      set so = $d/$so
      set ok = TRUE
      echo "   Using shared library '$so'"
      break
   endif
end
if ($ok == FALSE) then
#   echo "   Warning: '$so' not found in '$libdir'"
   @ nwarn = $nwarn + 1
endif

set ok  = FALSE
set arc = ( `grep -w arc $def` )
if ("$#arc" > 1) then
   set arc = $arc[2]
   foreach d ($libdir)
      if (-f $d/$arc) then
         set arc = $d/$arc
         set ok  = TRUE
         echo "   Using archive '$arc'"
         break
      endif
   end
   if ($ok == FALSE) then
#      echo "   Warning: '$arc' not found in '$libdir'"
      @ nwarn = $nwarn + 2
   endif
endif

# start a blank file now
# if it exits after this there will at least be a file
# that make can check for dependencies
rm -f $api >& /dev/null
touch $api

set ok  = FALSE
set hdr = ( `grep -w header $def` )
set hdr = $hdr[2]
foreach d ($incdir)
   if (-f $d/$hdr) then
      set hdr = $d/$hdr
      set ok  = TRUE
      break
   endif
end
if ($ok == FALSE) then
   echo "   Error: '$hdr' not found in '$incdir'"
   exit($fatal)
endif

set ppf = $devinc/$hdr:t.api
if ("$api" == "") then
   set api = $pck.api
endif
echo "   Generating '$api' from '$hdr'"

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PROCESS_PACKAGE_HEADER - make a clean list of functions, variables, and
#                        - typedefs defined by the package header
#
#   elide '{' '}' -                             remove struct bodies
#   sed 's/extern//g'                           get rid of extern
#   grep -v typedef                             get rid of typedefs
#

if (-f $hdr) then
   pcpp -o - $hdr                                  |& \
   elide '{' '}' -                                 |  \
   sed 's/extern//g'                               |  \
   grep -v typedef                                 |  \
   cat >&! $ppf
else
   @ nerr = $nerr + 2
endif

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

set fncl    = ""
set varl    = ""
set missing = ""

# look for specified functions to bind
set fok = FALSE
set vok = FALSE
@ nl = `cat $def | wc -l`
@ il = 0
while ($il < $nl)
   @ il = $il + 1
   set line = ( `head -n $il $def | tail -n 1` )
   if ("$line" == "") continue
   if ("$line" =~ \#*) continue
   if ("$line" =~ *functions\ \{) then
      set fok = TRUE
      continue
   endif
   if ("$line" =~ *variables\ \{) then
      set vok = TRUE
      continue
   endif
   if ("$line" =~ *\}*) then
      set fok = FALSE
      set vok = FALSE
      continue
   endif
   if ($fok == TRUE) then
      grep -w $line $ppf >& /dev/null
      if ($status == 0) then
         set fncl = ( $fncl $line )
      else
         set missing = ( $missing $line )
      endif

   else if ($vok == TRUE) then
      grep -w $line $ppf >& /dev/null
      if ($status == 0) then
         set varl = ( $varl $line )
      else
         set missing = ( $missing $line )
      endif
   endif
end

# if none are specified take them all
if ("$fncl" == "") then
   set noglob
   @ nl = `cat $ppf | wc -l`
   @ il = 0
   while ($il < $nl)
      @ il = $il + 1
      set line = ( `head -n $il $ppf | tail -n 1` )
      if ("$line" == "") continue
      if ("$line" =~ \#*) continue
      if ("$line" =~ *\(*) then
         set s = ( `echo "$line" | sed 's|(.*$||' | sed 's|\*||g'`)
         if (($#s > 1) && ("$s" !~ *attribute*)) then
            set t = $s[$#s]
            set fncl = ( $fncl $t )
         endif
      endif
   end
   unset noglob
endif

if ("$varl" == "") then
   @ nv = 0
else
   @ nv = $#varl
endif

# it is an error to specify no functions
# however we must generate a dummy API
@ nf = $#fncl
if ("$fncl" == "") then
   echo "   Warning: no functions found in $ppf"
   cat $ppf
   @ nf = 0
   @ nm = 0

else if ("$missing" != "") then
   @ nm = $#missing
   if ($nm == $nf) then
      echo "   Warning: all $nm functions missing in $ppf"
      cat $ppf
   else
      set t = $hdr:t
      @ n  = $nf + $nm
      echo "   Warning: missing $nm out of $n requested functions or variables for ${t}"
      foreach f ($missing)
         echo "      $f"
      end
      unset n
      unset t
      @ nwarn = $nwarn + 4
   endif
endif
unset missing

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

Note $api '/*'
Note $api " * $PCK.API - define $PCK API for PACT"
Note $api ' *'
Note $api ' * #include "cpyright.h"'
Note $api ' *'
Note $api ' */'
Note $api ''
Note $api "#ifndef ${PCK}_API_PACT"
Note $api ''
Note $api "#define ${PCK}_API_PACT"
Note $api ''
Note $api '#include <'$hdr:t'>'
Note $api ''

if (($nf > 0) || ($nv > 0)) then
   Note $api "typedef struct s_${pck}_api ${pck}_api;"
   Note $api ''
   Note $api "struct s_${pck}_api"
   Note $api '   {'

   set noglob
   foreach v ($varl)
      set m = v$v
      set t = ( `grep -w $v $ppf | sed "s|$v|*$m|"` )
      Note $api "    $t"
   end
   foreach f ($fncl)
      set m = '(*f'$f')'
      set t = ( `grep -w $f $ppf | sed "s|$f|$m|"` )
      Note $api "    $t"
   end
   unset noglob

   Note $api '   };'
   Note $api ''
   Note $api "static ${pck}_api"
   Note $api " _${pck}_;"
   Note $api ''
endif

Note $api '/*--------------------------------------------------------------------------*/'
Note $api '/*--------------------------------------------------------------------------*/'
Note $api ''
Note $api "/* _${PCK}_SET_API - setup the API for ${PCK} access */"
Note $api ''
Note $api "void _${PCK}_set_api(void)"
Note $api '   {'
Note $api ''

if (($nf > 0) || ($nv > 0)) then
   set m = f$fncl[1]
   Note $api "    if (_${pck}_.$m == NULL)"

   Note $api ''
   Note $api "#ifdef ${PCK}_SO"
   Note $api ''
   Note $api '/* dynamically linked way */'
   Note $api '       {int rv;'
   Note $api ''

   Note $api "	rv = SC_so_register_func(OBJ_SO, ${PCK}_SO, "'"'${pck}'",'
   Note $api '				 NULL, NULL, NULL, NULL);'
   Note $api '	if (rv == FALSE)'
   Note $api '	   SC_error(-1, "CANNOT LOAD '${so}'");'
   Note $api ''

   foreach v ($varl)
      set m = v$v
      Note $api "	_${pck}_.$m \t = SC_so_get(OBJ_SO, "'"'${pck}'", "'$v'");'
   end
   foreach f ($fncl)
      set m = f$f
      Note $api "	ASSIGN_FNC(_${pck}_.$m, \t SC_so_get(OBJ_SO, "'"'${pck}'", "'$f'"));'
   end

   Note $api '       }'
   Note $api ''
   Note $api '#else'
   Note $api ''
   Note $api '/* statically linked way */'
   Note $api '       {'
   Note $api ''

   foreach v ($varl)
      set m = v$v
      Note $api "	_${pck}_.$m \t = &$v;"
   end
   foreach f ($fncl)
      set m = f$f
      Note $api "	_${pck}_.$m \t = $f;"
   end

   Note $api '       };'
   Note $api ''
   Note $api '#endif'
   Note $api ''
endif

Note $api '    return;}'
Note $api ''
Note $api '/*--------------------------------------------------------------------------*/'
Note $api '/*--------------------------------------------------------------------------*/'
Note $api ''

if (($nf > 0) || ($nv > 0)) then
   foreach v ($varl)
      set m = v$v
      Note $api "#define $v \t "'*('_${pck}_.$m')'
   end
   foreach f ($fncl)
      set m = f$f
      Note $api "#define $f \t _${pck}_.$m"
   end
   Note $api ''
endif

Note $api '#endif'
Note $api ''

cat $api | sed 's|\\t|\t|g' >&! $api.new
mv $api.new $api

if (!(-f $api)) then
   @ nerr = $nerr + 8
endif

if ($nwarn > 0) then
   echo "   Completed with warning status $nwarn"
endif

if ($keep == FALSE) then
   rm -rf $ppf >& /dev/null
endif

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

exit($nerr)

