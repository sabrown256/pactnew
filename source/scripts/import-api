#!/bin/csh -f
#
# IMPORT-API - generate an API binding for a foreign package
#            - to be used by PACT and
#            - linked statically or dynamically as requested
#
# include "cpyright.h"
#

unalias *

set pact   = `which pact`
set bindir = $pact:h
set lbase  = $bindir:h

if (-d ../scripts) then
   source ../scripts/env-csh
else
   source $lbase/include/env-csh
endif

unset bindir
unset lbase

@ nerr = 0

set api    = ""
set def    = ""
set fatal  = 0
set keep   = FALSE
set noinc  = FALSE
set incdir = ( . /usr/include )
set libdir = ( . /lib64 /usr/lib64 /lib /usr/lib )

while ($#argv > 0)
   switch ($1)
      case -f:
           set fatal = 1
           breaksw
      case -h:
           echo ""
           echo "Usage: import-api [-f] [-h] [-i] [-k] [-I<incdir>]* [-L<libdir>]* [-o <api>] <def>"
           echo "   f      make errors fatal (exit with 1 instead of 0)"
           echo "   h      this help message"
           echo "   i      do not expand dependent includes"
           echo "   k      keep prototypes file"
           echo "   I      add <incdir> to include directory list"
           echo "   L      add <libdir> to lib directory list"
           echo "   o      name of generated API file"
           echo "   <def>  api definition file"
           echo ""
           exit(1)
      case -i:
           set noinc = TRUE
           breaksw
      case -I*:
           set t = ( `echo $1 | sed 's|-I||g' | sed 's|:| |g'` )
           set incdir = ( $t $incdir )
           unset t
           breaksw
      case -k:
           set keep = TRUE
           breaksw
      case -L*:
           set t = ( `echo $1 | sed 's|-L||g' | sed 's|:| |g'` )
           set libdir = ( $t $libdir )
           unset t
           breaksw
      case -o:
           shift
           set api = $1
           breaksw
      default:
           set def = $1
           breaksw
   endsw
   shift
end

if ("$def" == "") then
   echo "No API definition file specified - exiting"
   exit($fatal)
endif
if (!(-f "$def")) then
   echo "File '$def' does not exist - exiting"
   exit($fatal)
endif

set pck = ( `grep -w package $def` )
set pck = $pck[2]
set PCK = `echo $pck | tr "[a-z]" "[A-Z]"`

set so = ( `grep -w so $def` )
set so = $so[2]
set ok = FALSE
foreach d ($libdir)
   if (-f $d/$so) then
      set so = $d/$so
      set ok = TRUE
      echo "   Using shared library '$so'"
      break
   endif
end
if ($ok == FALSE) then
   echo "   Warning: '$so' not found in '$libdir'"
endif

set ok  = FALSE
set arc = ( `grep -w arc $def` )
if ("$#arc" > 1) then
   set arc = $arc[2]
   foreach d ($libdir)
      if (-f $d/$arc) then
         set arc = $d/$arc
         set ok  = TRUE
         echo "   Using archive '$arc'"
         break
      endif
   end
   if ($ok == FALSE) then
      echo "   Warning: '$arc' not found in '$libdir'"
   endif
endif

set ok  = FALSE
set hdr = ( `grep -w header $def` )
set hdr = $hdr[2]
foreach d ($incdir)
   if (-f $d/$hdr) then
      set hdr = $d/$hdr
      set ok  = TRUE
      break
   endif
end
if ($ok == FALSE) then
   echo "   Error: '$hdr' not found in '$incdir'"
   exit($fatal)
endif

set file = $cwd/$hdr:t.api
if ("$api" == "") then
   set api = $pck.api
endif
echo "   Generating '$api' from '$hdr'"
rm -f $api
touch $api

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PROCESS_PACKAGE_HEADER - make a clean list of functions, variables, and
#                        - typedefs defined by the package header
#
#   elide '{' '}' -                             remove struct bodies
#   sed 's/extern//g'                           get rid of extern
#   grep -v typedef                             get rid of typedefs
#

if (-f $hdr) then
   pcpp -o - $hdr                                  |& \
   elide '{' '}' -                                 |  \
   sed 's/extern//g'                               |  \
   grep -v typedef                                 |  \
   cat >&! $file
else
   @ nerr = $nerr + 2
endif

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

set fncl = ""

set missing = ""

# look for specified functions to bind
set ok = FALSE
@ nl = `cat $def | wc -l`
@ il = 0
while ($il < $nl)
   @ il = $il + 1
   set line = ( `head -n $il $def | tail -n 1` )
   if ("$line" == "") continue
   if ("$line" =~ \#*) continue
   if ("$line" =~ *functions\ \{) then
      set ok = TRUE
      continue
   endif
   if ("$line" =~ *\}*) then
      set ok = FALSE
      continue
   endif
   if ($ok == TRUE) then
      grep -w $line $file >& /dev/null
      if ($status == 0) then
         set fncl = ( $fncl $line )
      else
         set missing = ( $missing $line )
      endif
   endif
end

# if none are specified take them all
if ("$fncl" == "") then
   set noglob
   @ nl = `cat $file | wc -l`
   @ il = 0
   while ($il < $nl)
      @ il = $il + 1
      set line = ( `head -n $il $file | tail -n 1` )
      if ("$line" == "") continue
      if ("$line" =~ \#*) continue
      if ("$line" =~ *\(*) then
         set s = ( `echo "$line" | sed 's|(.*$||' | sed 's|\*||g'`)
         if (($#s > 1) && ("$s" !~ *attribute*)) then
            set t = $s[$#s]
            set fncl = ( $fncl $t )
         endif
      endif
   end
   unset noglob
endif

# it is an error to specify no functions
if ("$fncl" == "") then
   @ nerr = $nerr + 4
endif

if ("$missing" != "") then
   set t = $hdr:t
   echo "Missing $#missing requested functions for ${t}:"
   foreach f ($missing)
      echo "   $f"
   end
   unset t
endif
unset missing

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

Note $api '/*'
Note $api " * $PCK.API - define $PCK API for PACT"
Note $api ' *'
Note $api ' * #include "cpyright.h"'
Note $api ' *'
Note $api ' */'
Note $api ''
Note $api "#ifndef ${PCK}_API_PACT"
Note $api ''
Note $api "#define ${PCK}_API_PACT"
Note $api ''
Note $api '#include <'$hdr:t'>'
Note $api ''
Note $api "typedef struct s_${pck}_api ${pck}_api;"
Note $api ''
Note $api "struct s_${pck}_api"
Note $api '   {'

set noglob
foreach f ($fncl)
   set m = '(*f'$f')'
   set t = ( `grep -w $f $file | sed "s|$f|$m|"` )
   Note $api "    $t"
end
unset noglob

Note $api '   };'
Note $api ''
Note $api "static ${pck}_api"
Note $api " _${pck}_;"
Note $api ''
Note $api '/*--------------------------------------------------------------------------*/'
Note $api '/*--------------------------------------------------------------------------*/'
Note $api ''
Note $api "/* _${PCK}_SET_API - setup the API for ${PCK} access */"
Note $api ''
Note $api "void _${PCK}_set_api(void)"
Note $api '   {'
Note $api ''

set m = f$fncl[1]
Note $api "    if (_${pck}_.$m == NULL)"

Note $api ''
Note $api "#ifdef ${PCK}_SO"
Note $api ''
Note $api '/* dynamically linked way */'
Note $api '       {int rv;'
Note $api ''
Note $api '	rv = SC_so_register_func(OBJ_SO, "'${so}'", "'${pck}'",'
Note $api '				 NULL, NULL, NULL, NULL);'
Note $api '	if (rv == FALSE)'
Note $api '	   SC_error(-1, "CANNOT LOAD '${so}'");'
Note $api ''

foreach f ($fncl)
   set m = f$f
   Note $api "	_${pck}_.$m \t = SC_so_get(OBJ_SO, "'"'${pck}'", "'$f'");'
end

Note $api '       }'
Note $api ''
Note $api '#else'
Note $api ''
Note $api '/* statically linked way */'
Note $api '       {'
Note $api ''

foreach f ($fncl)
   set m = f$f
   Note $api "	_${pck}_.$m \t = $f;"
end

Note $api '       };'
Note $api ''
Note $api '#endif'
Note $api ''
Note $api '    return;}'
Note $api ''
Note $api '/*--------------------------------------------------------------------------*/'
Note $api '/*--------------------------------------------------------------------------*/'
Note $api ''

foreach f ($fncl)
   set m = f$f
   Note $api "#define $f \t _${pck}_.$m"
end

Note $api ''
Note $api '#endif'
Note $api ''

cat $api | sed 's|\\t|\t|g' >&! $api.new
mv $api.new $api

if (!(-f $api)) then
   @ nerr = $nerr + 8
endif

if ($keep == FALSE) then
   rm -rf $file
endif

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

exit($nerr)

