#!/bin/csh -f
#
# ENVF - write out environment information
#      - write versions for CSH, SH, and dotkit families
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

unalias *

if (-f ../scripts/env-csh) then
   set SrcDir = $cwd
else if (-f ../../scripts/env-csh) then
   set SrcDir = $cwd:h
endif
set ldir = $SrcDir:h/scripts
set path = ( $ldir $path )
source $ldir/env-csh

set vl = ""
set vl = ( $vl HAVE_OPENMP HAVE_READLINE )
set vl = ( $vl HAVE_PYTHON PY_Vers )
set vl = ( $vl SYS_SITE SYS_TYPE DAS_ROOT DAI_ROOT )

source $MngDir/write/import-db

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

    set lnotice = $1

    Separator $Log
    if ($lnotice == TRUE) then
       NoteD $Log "   Environment setup files - env-pact"
    else
       Note $Log "   Environment setup files - env-pact"
    endif
    Note $Log " "

    set tmpF = $SEFile.tmp
    $RM $tmpF
    touch $tmpF
    Note $tmpF "setenv SYS_TYPE $SYS_TYPE"
    Note $tmpF "setenv SYS_SITE $SYS_SITE"
    Note $tmpF "setenv DAS_ROOT $DAS_ROOT"
    Note $tmpF "setenv DAI_ROOT $DAI_ROOT"

# make a temporary approximation to EnvCsh
    cat $SEFile | \
    awk '$1 != "PATH" {print "setenv " $0}' >> $tmpF

# use the C Shell to expand and print unique environment variable settings
# in Bourne Shell syntax
    /bin/csh -fc '(source clearenv ; source '$tmpF' ; env)' |& \
    awk '{printf("export %s\"\n", $0);}'                    |  \
    tr "\t" " "                                             |  \
    sed 's/= */=/'                                          |  \
    sed 's/=/="/' >&! $EnvSh

# reprocess to get C Shell settings
    cat $EnvSh | sed 's/export/setenv/' | sed 's/=/ /' >&! $EnvCsh

# the dotkit representation is the same as the C Shell at this point
    cp $EnvCsh $EnvDk
    $RM $tmpF
    unset tmpF

# do special handling for PATH and RPATH
    flog $Log set EPath = ""
    set length = `wc -l $SEFile`
    @ nl = $length[1]
    @ il = 1
    while ($il <= $nl)
       set ln = `head -n $il $SEFile | tail -n 1`
       set var = $ln[1]
       set val = "$ln[2-]"

       if ("$var" == PATH) then
          set tPath = `echo "$val" | sed 's|\${PATH}|'$EPath'|g'`
          set EPath = `echo "$tPath" | sed 's|\$PATH|'$EPath'|g'`
       endif
       @ il = $il + 1
    end

    Note $EnvCsh ""
    Note $EnvSh ""
    Note $EnvDk ""

# emit MANPATH settings
    Note $EnvCsh 'if ($?MANPATH == 1) then'
    Note $EnvCsh '   setenv MANPATH '$SysDir'/man:$MANPATH'
    Note $EnvCsh 'else'
    Note $EnvCsh '   setenv MANPATH '$SysDir'/man:'
    Note $EnvCsh 'endif'
    Note $EnvCsh ""

    Note $EnvSh 'if [ "$MANPATH" != "" ]; then'
    Note $EnvSh "   export MANPATH=$SysDir/man"':$MANPATH'
    Note $EnvSh "else"
    Note $EnvSh "   export MANPATH=$SysDir/man"
    Note $EnvSh "fi"
    Note $EnvSh ""

    Note $EnvDk 'dk_alter MANPATH '$SysDir'/man'
    Note $EnvDk ""

    if ($?HAVE_PYTHON) then
       if ($HAVE_PYTHON == TRUE) then
          set lPython = $LibDir/python$PY_Vers
          if ($?PYTHONPATH) then
             if (`expr "$PYTHONPATH" : '.*'$lPython'.*'` == 0) then
                setenv PYTHONPATH ${lPython}:$PYTHONPATH
             endif
          else
             setenv PYTHONPATH ${lPython}
          endif
          unset lPython
          Note $EnvCsh "setenv PYTHONPATH $PYTHONPATH"
          Note $EnvDk  "dk_setenv PYTHONPATH $PYTHONPATH"
          Note $EnvSh  "export PYTHONPATH=$PYTHONPATH"
       endif
    endif

# emit PATH settings
    if ("$EPath" != "") then
       foreach dir (`echo $EPath | sed 's/:/ /g'`)
          Note $EnvDk  "dk_alter PATH $dir"
       end
       set EPath = `echo "$EPath"':$PATH' | sed 's/::/:/g'`
       Note $EnvCsh "setenv PATH    $SysDir/bin:${EPath}"
       Note $EnvSh  "export PATH=$SysDir/bin:${EPath}"
    else
       Note $EnvCsh 'setenv PATH    '$SysDir'/bin:$PATH'
       Note $EnvSh 'export PATH='$SysDir'/bin:$PATH'
       Note $EnvDk 'dk_alter  PATH    '$SysDir'/bin'
    endif

# write the CSH version like this because PCSH scripts like
# PDBView need to get the users SCHEME variable if defined
    Note $EnvCsh 'if ($?SCHEME == 1) then'
    Note $EnvCsh '   setenv SCHEME  ${SCHEME}:'"$SysDir/scheme"
    Note $EnvCsh 'else'
    Note $EnvCsh "   setenv SCHEME  $SysDir/scheme"
    Note $EnvCsh 'endif'
    Note $EnvCsh "setenv ULTRA   $SysDir/scheme"

    Note $EnvSh "export SCHEME=$SysDir/scheme"
    Note $EnvSh "export ULTRA=$SysDir/scheme"
    Note $EnvDk "dk_setenv SCHEME  $SysDir/scheme"
    Note $EnvDk "dk_setenv ULTRA   $SysDir/scheme"

    flog $Log cat $EnvCsh
    flog $Log cat $EnvSh
    flog $Log cat $EnvDk

# source this now before trying to compile smake in WriteMAKEM
    Note $Log "Sourcing $EnvCsh"
    source $EnvCsh

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

exit(0)

