#!/bin/csh -f
#
# ITF90 - generate F90 interfaces from PACT sources
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

set Err   = 0
set Arch  = `cfgman use`
set ZArch = z-$Arch
set Which = "$cwd/pwhich"

source ../dev/$Arch/include/env-pact.csh
source ../dev/$Arch/include/env-csh

if ($CROSS_COMPILE == FALSE) then
   set CFE = ""
else
   set CFE = "do-run"
endif

InitLog Log $cwd:h/dev/$Arch/log/itf90

set FC     = `pact +l -info FCompiler`
set IncDir = $cwd:h/dev/$Arch/include
set SzAddr = `$CFE detect | grep "A pointer is"`
set SzAddr = $SzAddr[4]

if ("$FC" == "") then
   NoteD $Log "No Fortran compiler specified - exiting"
   exit(1)
endif

set FCExe = `$Which $FC`
if (!(-x "$FCExe")) then
   NoteD $Log "Fortran compiler $FC not found - exiting"
   exit(2)
endif

NoteD $Log ""
NoteD $Log "Generating F90 interfaces using:"
NoteD $Log "   Compiler:  $FCExe"
NoteD $Log "   Includes:  $IncDir"
NoteD $Log "   Addr size: $SzAddr"
NoteD $Log ""

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# GENERATE - generate interfaces for each package

flog $Log set Dirs = ( score pml pdb ppc pgs panacea scheme sx ultra )
foreach d ($Dirs)

   Separator $Log
   flog $Log pushd ../$d

   @ CCount = `echo $d | wc -c`
   @ NDots  = 20 - $CCount
   set Fill = "$d "
   while ($NDots > 0)
      set Fill = "$Fill."
      @ NDots = $NDots - 1
   end

   NoteD $Log -n "   $Fill "
   Note $Log ""

   flog $Log set Mod = $ZArch/$d-itf.f90

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PARSE - parse the pre-Make file and make a file list

   set Lst = ( `grep '${TGTLib}(' pre-Make | sed 's/TGTLib//g' | sed 's/[=()$\]//g'` )
   set Files = ""
   foreach i ($Lst)
      set j = $i:r.c
      if (-f $j) then
         set Files = ( $Files $j )
      endif
   end

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# TRANSFORM - process the C declarations into F90 interface blocks
#           - the transformations are:
#   sed 's/[ \t][ \t]*/ /g'               compress white space
#   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }     join lines ending in ','
#        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }'
#   grep 'F77_FUNC('                    
#   grep -v "#"                           suppress #define F77_FUNC
#   grep -v ";"                           suppress ... F77_FUNC(x,X)(...);
#   grep -v "="                           suppress x = F77_FUNC(x,X)(...
#   sed 's/, .*)(/(/'                     F77_FUNC(x, X)(  -> F77_FUNC(x)(
#   sed 's/F77_FUNC(//'                   F77_FUNC(x)      -> x
#   sed 's/(void)/()/'                    (void)           -> ()
#   sed 's/(/ /'                          '('              -> ' '
#   sed 's/)$/ END/'                      foo(...)         -> foo(... END
#   sed 's/FIXNUM/integer/g'              FIXNUM           -> integer
#   sed 's/char *\*/integer(isizea) /g'   char **          -> integer(isizea)
#   sed 's/void *\*/integer(isizea) /g'   void [*]*        -> integer(isizea)
#   sed 's/integer *\*/integer /g'        integer *        -> integer
#   sed 's/REAL *\*/real /g'              REAL *           -> real
#   sed 's/double *\*/real /g'            double *         -> real
#   sed 's/REAL/real/g'                   REAL             -> real
#   sed 's/double/real/g'                 double           -> real
#   sed 's/*//g'                          '*'              -> ''
#   sed 's/,/ /g'                         ','              -> ' '
#   sed 's/F77_string/character*(*)/g'    F77_string       -> character*(*)
#   sed 's/PF[^ ]* /external /g'          function pointer -> external
#

   cat $Files                                     | \
   sed 's/[ \t][ \t]*/ /g'                        | \
   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }      \
        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }' | \
   grep 'F77_FUNC('                               | \
   grep -v "#"                                    | \
   grep -v ";"                                    | \
   grep -v "="                                    | \
   sed 's/, .*)(/(/'                              | \
   sed 's/F77_FUNC(//'                            | \
   sed 's/(void)/()/'                             | \
   sed 's/(/ /'                                   | \
   sed 's/)[ \t]*$/ END/'                         | \
   sed 's/FIXNUM/integer/g'                       | \
   sed 's/char *\*/integer(isizea) /g'            | \
   sed 's/void *\*/integer(isizea) /g'            | \
   sed 's/integer *\*/integer /g'                 | \
   sed 's/REAL *\*/real /g'                       | \
   sed 's/double *\*/real /g'                     | \
   sed 's/REAL/real/g'                            | \
   sed 's/double/real/g'                          | \
   sed 's/*//g'                                   | \
   sed 's/,/ /g'                                  | \
   sed 's/F77_string/character*(*)/g'             | \
   sed 's/PF[^ ]* /external /g'                   | \
   sed 's/.*:/      /'                            | \
   cat >&! $Mod.tmp

   flog $Log cat $Mod.tmp
   flog $Log @ Length = `cat $Mod.tmp | wc -l`
   if ($Length < 1) then
      Note $Log "There are no F90 callable functions in $d"
      NoteD $Log "none"
      flog $Log $RM Mod.tmp
      continue
   endif

# declare the incomplete ones as external
   cat $Mod.tmp                                                         | \
   awk '{if (($0 ~ /\.\.\./) || ($NF != "END"))                           \
            {if ($1 == "void")                                            \
                {printf("   external :: %s\n", $2);}                      \
             else                                                         \
                {printf("   %s, external :: %s\n", $1, $2);};};}'       | \
   cat >&! $Mod.ext

   @ LnExt = `cat $Mod.ext | wc -l`
   Note $Log "Length of $Mod.ext is $LnExt lines"
   flog $Log cat $Mod.ext

# emit complete declarations
   cat $Mod.tmp                                                         | \
   awk '{if ($1 == "void")                                                \
            {oper = "subroutine";}                                        \
         else                                                             \
            {oper = "function";}                                          \
         if (($0 !~ /\.\.\./) && ($NF == "END"))                          \
            {printf("      %s %s(", oper, $2);                            \
             for (i = 4; i < NF; i += 2)                                  \
                 {if (i == 4)                                             \
                     {printf("%s", $i);}                                  \
                  else if ((i - 4) % 16 == 0)                             \
                     {printf(", &\n                      %s", $i);}       \
                  else                                                    \
                     {printf(", %s", $i);};};                             \
             printf(")\n");                                               \
             if ($0 ~ /(isizea)/)                                         \
                {printf("         use XXXtypes\n");};                     \
             printf("         implicit none\n");                          \
             if (oper == "function")                                      \
                {printf("         %-16s :: %s\n", $1, $2);};              \
             for (i = 3; i < NF; i += 2)                                  \
                 {printf("         %-16s :: %s\n", $i, $(i+1));};         \
                  printf("      end %s %s\n", oper, $2);                  \
                  printf("\n");};}'                                     | \
   sed 's/XXX/'$d'/'                                                    | \
   cat >&! $Mod.itf

   @ LnItf = `cat $Mod.itf | wc -l`
   Note $Log "Length of $Mod.itf is $LnItf lines"
   flog $Log cat $Mod.itf

   flog $Log rm -f $Mod.tmp

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# WRITE - write the final interface file

   flog $Log rm -f $Mod
   flog $Log touch $Mod

   set FName = `echo "$d-itf.f90" | tr "[a-z]" "[A-Z]"`

   @ CCount = `echo $FName | wc -c`
   @ NDots  = $CCount - 1
   set Fill = ""
   while ($NDots > 0)
      set Fill = "$Fill "
      @ NDots = $NDots - 1
   end

   Note $Mod "!"
   Note $Mod "! $FName - F90 interfaces for $d"
   Note $Mod "! $Fill - NOTE: this file was automatically generated"
   Note $Mod "! $Fill - any manual changes will not be effective"
   Note $Mod "!"
   Note $Mod ""

# if there are no interfaces there is no need for the types module
   if ($LnItf > 0) then
      Note $Mod "module ${d}types"
      Note $Mod "   integer, parameter :: isizea = $SzAddr"
      Note $Mod "end module ${d}types"
      Note $Mod ""
   endif

   Note $Mod "module $d"
   Note $Mod ""

# add external declarations
   if ($LnExt > 0) then
      cat $Mod.ext >>& $Mod
      Note $Mod ""
   endif

# add interfaces
   if ($LnItf > 0) then
      Note $Mod "   interface"
      Note $Mod ""

      cat $Mod.itf >>& $Mod

      Note $Mod "   end interface"
      Note $Mod ""
   endif

   Note $Mod "end module $d"
   Note $Mod ""

   flog $Log rm -f $Mod.ext $Mod.itf
   flog $Log cat $Mod

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# COMPILE - compile the module file

   flog $Log pushd $ZArch
   flog $Log set lMod = $Mod:t
   flog $Log $FC -c $lMod
   set xstatus = $status

   flog $Log mv $d*.mod $IncDir
   flog $Log $RM $d*.o
   flog $Log popd

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   if ($xstatus == 0) then
      NoteD $Log "ok"
   else
      NoteD $Log "ng"
   endif
   flog $Log popd
end

flog $Log ls -l $cwd:h/dev/$Arch/include/*.mod

exit($Err)

