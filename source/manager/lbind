#!/bin/csh -f
#
# LBIND - generate wrappers of C functions for SCHEME and Fortran
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

unalias *

set Err   = 0
set Arch  = `cfgman use`
set ZArch = z-$Arch
set Which = "$cwd/pwhich"

source ../dev/$Arch/include/env-pact.csh
source ../dev/$Arch/include/env-csh

SafeEnv CROSS_COMPILE FALSE

if ($CROSS_COMPILE == FALSE) then
   set CFE = ""
else
   set CFE = "do-run"
endif

InitLog Log $cwd:h/dev/$Arch/log/lbind

set FC      = `pact +l -info FCompiler`
set BaseDir = $cwd:h/dev/$Arch
set IncDir  = $BaseDir/include
set LibDir  = $BaseDir/lib
set SzAddr  = `$CFE detect | grep "A pointer is"`
set SzAddr  = $SzAddr[4]

if ("$FC" == "") then
   NoteD $Log "   No Fortran compiler specified - exiting"
   exit(1)
endif

set FCExe = `$Which $FC`
if (!(-x "$FCExe")) then
   NoteD $Log "   Fortran compiler $FC not found - exiting"
   exit(2)
endif

set FCFlags = `pact +l -info FFLAGS`
set AR      = `pact +l -info AR`
set AROpt   = `pact +l -info AROpt`

Note $Log ""
NoteD $Log "   Generating F90 interfaces using:"
Note $Log "      Compiler:  $FCExe"
Note $Log "      Includes:  $IncDir"
Note $Log "      Addr size: $SzAddr"
Note $Log "      AR:        $AR"
Note $Log "      AROpt:     $AROpt"
Note $Log ""

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# GENERATE - generate interfaces for each package

flog $Log set Dirs = ( score pml pdb ppc pgs panacea scheme sx ultra )
foreach d ($Dirs)

   Separator $Log
   flog $Log pushd ../$d

   @ CCount = `echo $d | wc -c`
   @ NDots  = 20 - $CCount
   set Fill = "$d "
   while ($NDots > 0)
      set Fill = "$Fill."
      @ NDots = $NDots - 1
   end

   NoteD $Log -n "      $Fill "
   Note $Log ""

   flog $Log set Mod = $ZArch/$d-itf.f

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PARSE - parse the pre-Make file and make a file list

   set Lst = ( `grep '${TGTLib}(' pre-Make | sed 's/TGTLib//g' | sed 's/[=()$\]//g'` )
   set Files = ""
   foreach i ($Lst)
      set j = $i:r.c
      if (-f $j) then
         set Files = ( $Files $j )
      endif
   end

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# TRANSFORM - process the C declarations
#           - the transformations are:
#   elide '/*' '*/' $Files                         remove C comments
#   elide '{' '}' -                                remove compound statements
#   sed 'N;s/\\\n//'                               combine lines ending in \
#   elide '#if' '#endif' -                         remove conditionals
#   grep -v '#'                                    remove #include, #define
#   sed 's/[ \t][ \t]*/ /g'                        compress whitespace
#   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }    
#        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }' combine lines ending in ,
#   sed '/^[ \t]*$/d'                              remove blank lines
#   sed '/;[ \t]*$/d'                              remove lines ending in ;
#   grep -v '='                                    remove lines with assignments
#

   elide '/*' '*/' $Files                          | \
   elide '{' '}' -                                 | \
   sed 'N;s/\\\n//'                                | \
   elide '#if' '#endif' -                          | \
   grep -v '#'                                     | \
   sed 's/[ \t][ \t]*/ /g'                         | \
   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }       \
        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }'  | \
   sed '/^[ \t]*$/d'                               | \
   sed '/;[ \t]*$/d'                               | \
   grep -v '='                                     | \
   grep -v 'FIXNUM'                                | \
   grep -v 'static'                                | \
   grep '('                                        | \
   sort                                            | \
   cat >&! $Mod.tmp

# Fortran binding

# Scheme binding

# Python binding

# Document

echo "Result:"
cat $Mod.tmp
exit(1)

   flog $Log cat $Mod.tmp
   flog $Log @ Length = `cat $Mod.tmp | wc -l`
   if ($Length < 1) then
      Note $Log "There are no F90 callable functions in $d"
      NoteD $Log "none"
      flog $Log $RM Mod.tmp
      continue
   endif

# declare the incomplete ones as external
   cat $Mod.tmp                                                         | \
   awk '{if (($0 ~ /\.\.\./) || ($NF != "END"))                           \
            {if ($1 == "void")                                            \
                {printf("   external :: %s\n", $2);}                      \
             else                                                         \
                {printf("   %s, external :: %s\n", $1, $2);};};}'       | \
   cat >&! $Mod.ext

   @ LnExt = `cat $Mod.ext | wc -l`
   Note $Log "Length of $Mod.ext is $LnExt lines"
   flog $Log cat $Mod.ext

# emit complete declarations
   cat $Mod.tmp                                                         | \
   awk '{if ($1 == "void")                                                \
            {oper = "subroutine";}                                        \
         else                                                             \
            {oper = "function";}                                          \
         if (($0 !~ /\.\.\./) && ($NF == "END"))                          \
            {printf("      %s %s(", oper, $2);                            \
             for (i = 4; i < NF; i += 2)                                  \
                 {if (i == 4)                                             \
                     {printf("%s", $i);}                                  \
                  else if ((i - 4) % 16 == 0)                             \
                     {printf(", &\n                      %s", $i);}       \
                  else                                                    \
                     {printf(", %s", $i);};};                             \
             printf(")\n");                                               \
             if ($0 ~ /(isizea)/)                                         \
                {printf("         use XXXtypes\n");};                     \
             printf("         implicit none\n");                          \
             if (oper == "function")                                      \
                {printf("         %-16s :: %s\n", $1, $2);};              \
             for (i = 3; i < NF; i += 2)                                  \
                 {printf("         %-16s :: %s\n", $i, $(i+1));};         \
                  printf("      end %s %s\n", oper, $2);                  \
                  printf("\n");};}'                                     | \
   sed 's/XXX/'$d'/'                                                    | \
   cat >&! $Mod.itf

   @ LnItf = `cat $Mod.itf | wc -l`
   Note $Log "Length of $Mod.itf is $LnItf lines"
   flog $Log cat $Mod.itf

   flog $Log rm -f $Mod.tmp

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# WRITE - write the final interface file

   flog $Log rm -f $Mod
   flog $Log touch $Mod

   set FName = `echo "$d-itf.f" | tr "[a-z]" "[A-Z]"`

   @ CCount = `echo $FName | wc -c`
   @ NDots  = $CCount - 1
   set Fill = ""
   while ($NDots > 0)
      set Fill = "$Fill "
      @ NDots = $NDots - 1
   end

   Note $Mod "\!"
   Note $Mod "\! $FName - F90 interfaces for $d"
   Note $Mod "\! $Fill - NOTE: this file was automatically generated"
   Note $Mod "\! $Fill - any manual changes will not be effective"
   Note $Mod "\!"
   Note $Mod ""

# if there are no interfaces there is no need for the types module
   if ($LnItf > 0) then
      Note $Mod "module ${d}types"
      Note $Mod "   integer, parameter :: isizea = $SzAddr"
      Note $Mod "end module ${d}types"
      Note $Mod ""
   endif

   Note $Mod "module $d"
   Note $Mod ""

# add external declarations
   if ($LnExt > 0) then
      cat $Mod.ext >>& $Mod
      Note $Mod ""
   endif

# add interfaces
   if ($LnItf > 0) then
      Note $Mod "   interface"
      Note $Mod ""

      cat $Mod.itf >>& $Mod

      Note $Mod "   end interface"
      Note $Mod ""
   endif

   Note $Mod "end module $d"
   Note $Mod ""

   flog $Log rm -f $Mod.ext $Mod.itf
   flog $Log cat $Mod

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# COMPILE - compile the module file

   flog $Log pushd $ZArch
   flog $Log set lMod = $Mod:t
   flog $Log $FC $FCFlags -c $lMod
   set xstatus = $status

   flog $Log ls $d*
   flog $Log mv $d*.mod $IncDir
   flog $Log set TGTLib = $LibDir/lib${d}.a
   if (-f $TGTLib) then
      flog $Log $AR $AROpt $TGTLib $d*.o
   endif
   flog $Log $RM $d*.o
   flog $Log popd

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   if ($xstatus == 0) then
      NoteD $Log "ok"
   else
      NoteD $Log "ng"
   endif
   flog $Log popd
end

flog $Log ls -l $cwd:h/dev/$Arch/include/*.mod

exit($Err)

