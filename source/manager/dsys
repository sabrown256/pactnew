#!/bin/csh -f
#
# DSYS - developer's work script 
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

unalias *

# give a chance to do something at the beginning
if ($?PACT_DSYS_PRE == 1) then
   if (-f $PACT_DSYS_PRE) then
      source $PACT_DSYS_PRE
   endif
endif

# a little mess curtesy of cygwin
if ($?SHELL == 0) then
   if (-x /bin/csh) then
      setenv SHELL /bin/csh
   else if (-x /bin/bash) then
      setenv SHELL /bin/bash
   else
      setenv SHELL /bin/sh
   endif
endif

# invoking this dsys moves you into the manager directory
set BldDir = `dirname $0`
pushd $BldDir >& /dev/null

set psy_mngdir = $cwd
setenv PSY_Base   $psy_mngdir:h
setenv PSY_ScrDir $PSY_Base/scripts

# unset these in case they are set to nonsense
# GOTCHA: what do we do if these are set to necessary good values
unsetenv PSY_TYPE
unsetenv PSY_SITE
unsetenv PSY_AIRoot
unsetenv PSY_ASRoot

if (-f $psy_mngdir/extensions/sys-site) then
   eval `$psy_mngdir/extensions/sys-site`
else
   eval `$PSY_ScrDir/sys-site -du -f $psy_mngdir/local/site-signature`
endif

source $PSY_ScrDir/functions-pact.csh
source $PSY_ScrDir/csh-subroutines
HAVE_SUBROUTINES

unsetenv BASH_ENV
umask 007

unset psy_mngdir
unset PSY_ID
unsetenv PSY_ID

eval `$PSY_ScrDir/cfgsys`

setenv PACTVer     `cat $PSY_MngDir/.pact-version`

# directory name conventions
# to be consistenly used in config, build, test, and install
#   ..../pact              ->     PSY_Base
#   ..../pact/manager      ->     PSY_MngDir
#   ..../pact/scripts      ->     PSY_ScrDir
#   ..../pact/<pkg>        ->     PkgDir
#   ..../pact/dev          ->     DevDir
#   ..../pact/dev/$psy_id  ->     PSY_Root

set DevDir  = $PSY_Base/dev
set IncDir  = $PSY_Root/include
set BinDir  = $PSY_Root/bin
set LibDir  = $PSY_Root/lib
set EtcDir  = $PSY_Root/etc
set LogDir  = $PSY_Root/log
set ScmDir  = $PSY_Root/scheme
set PACT    = $BinDir/pact
set EnvCsh  = $EtcDir/env-pact.csh

set PCKS     = "-"
set Tmp      = tmp_$PSY_ID
set hsy_host = `uname -n`
set Time     = time

set DSYS    = $PSY_MngDir/dsys
set TIMER   = $PSY_ScrDir/timer

set path = ( $path . )

# put ../scripts on the end of the path just in case - bootstrap
set path = ( $path $PSY_ScrDir )

# if we have the issue ticket tracker available note it
set HaveTicket = FALSE
set BugTck     = /usr/gapps/pact/pactbug
if (-x $BugTck) then
   set HaveTicket = TRUE
endif

setenv PERDB   $BinDir/perdb
setenv GEXEC   $BinDir/gexec

if ($PSY_Arch !~ cygwin*) then
   limit stacksize unlimited >& /dev/null
endif

set Cmnd = $1
shift

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# make sure that the installation directories exist

if ("$Cmnd" != "dirs") then
   $DSYS dirs
endif

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

if ($#argv > 0) then
   if ("$1" == "-time") then
      set Time = ""
      shift
   endif
endif

if ((-e $EnvCsh) && ("$Cmnd" != config) && ("$Cmnd" != reconfig)) then
   source $EnvCsh

# remove any pact version from the path
   eval `$PSY_ScrDir/simplify-path -p pact`

endif

# remove any potential to change results by looking elsewhere
# than the builds and tests want to look
unsetenv SCHEME
unsetenv ULTRA

set RStatus = 0

switch ($Cmnd)
   case -h:
   case help:
        echo " "
        echo "DSYS - simulation system developers script "
        echo " "
        echo "Usage: dsys <command> <options> "
        echo " "
        echo "Commands: build         - compile and load the system codes"
        echo "          clean         - clean out the source directories"
        echo "          commit        - commit source/builder/doc changes into repository"
        echo "                        - commit message is built from remaining args"
        echo "          config        - configure the sources for the current platform"
        echo "          configured    - report the current configuration"
        echo "          delete        - remove all subdirectories and ancillary files"
        echo "                          pertaining to a specified architecture"
        echo "                          (Type 'dsys delete -h' for options.)"
        echo "          diff-hdrs     - diff the headers against the repository"
        echo "          dist          - make a distribution file"
        echo "          force-install - force install for specified configuration"
        echo "          import        - import sources (repository to repository)"
        echo "          info          - print info about PACT including"
        echo "                          log - review commit log"
        echo "                          tags - list revision tags"
        echo "                          space - find size of bins, libs, and includes"
        echo "          install       - install the system codes in public"
        echo "          net-update    - run a do-net without some bootstrapping problems"
        echo "          pact          - control the pact link to either smake or dmake"
        echo "          reconfig      - re-configure according to last configuration"
        echo "          remove        - remove the binaries in ../dev"
        echo "          post          - post a new distribution"
        echo "          select        - change configuration when using multiple"
        echo "                          configurations per platform"
        echo "          shared        - build PACT and its shared libraries"
        echo "          stats         - plot timing information from update logs"
        echo "          stats-update  - create ultra files with timing information from update logs"
        echo "          sync          - update sources with repository "
        echo "          sync-repo     - update one repository from another"
        echo "          tag           - tag the sources"
        echo "          test          - test the system codes"
        echo "          test-ssh      - test the SSH connections"
        echo "          update-sys    - update PACT versions at all sites using"
        echo "                          the update-sys utility"

        if ($HaveTicket == TRUE) then
           echo "          ticket       - interact with the issue ticket tracker"
        endif

        echo "          unlock       - unlock the repository"
        echo "          update       - update an installation"
        echo "          -h           - print this help message"
        echo "          -V           - force make macros to be verbose during compilation"
        echo " "
        exit(1)

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case build:
        echo ""

        set Shared = ( `dsys configured | awk '$1 == "Shared" { print $3 }'` )
        if ("$Shared" == "yes") then
           set MTgt = shared
           set Msg  = "shared and static"
        else
           set MTgt = link
           set Msg  = "static"
        endif

        set ThreadMake = ""
        set Make = `pact -info make`
        set Make = $Make:t

#        set Args = "-dbg"
        set Args = ""
        set Tgts = ""
        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   setenv SESSION_CONFIG $1
                   breaksw
              case -all :
                   ./bpc $argv
                   exit($status)
                   breaksw
              case -dbg :
                   set Args = ( $Args $1 )
                   breaksw
              case -h :
                   echo ""
                   echo "Usage: dsys build [-a <sys>] [-all] [-h] [-na #] [-p #] [-s] [-u] [tgts]*"
                   echo ""
                   echo "     a   - do build for configuration <sys>"
                   echo "     all - build all current configurations"
                   echo "     h   - this help message"
                   echo "     na  - number of attempts when commands fail"
                   echo "     p   - number of nodes to use"
                   echo "     s   - build shared libraries if configured"
                   echo "     u   - build static libraries only (default)"
                   echo ""
                   exit(1)
                   breaksw
              case -na :
                   shift
                   set Args = ( $Args +na $1 )
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -s :
                   shift
                   set MTgt = shared
                   breaksw
              case -u :
                   shift
                   set MTgt = build
                   breaksw
              case -o :
                   shift
                   breaksw
              case -* :
                   set Args = ( $Args $argv )
                   breaksw
              default :
                   set Tgts = ( $Tgts $1 )
                   breaksw
           endsw
           shift
        end

        set DevDir = $PSY_Base/dev

        setenv PSY_ID   `$PSY_CfgMan -d ../dev use`
        setenv PSY_Root $DevDir/$PSY_ID

        set BinDir = $PSY_Root/bin
        set EtcDir = $PSY_Root/etc
        set LogDir = $PSY_Root/log

        InitLog Log $LogDir/build

        flog $Log ( where pact |& head -n 1 )

        set BeginTime = `$TIMER -r`

        flog $Log umask
        flog $Log setenv SC_EXEC_LOG_FILE ${LogDir}/build.error

# do not bother with core files for the compilation tools
        limit coredumpsize 0 >& /dev/null

# provide context for child processes
        setenv DSYS_TARGET pact_build

# preliminary - generate headers in score needed by other packages
        flog $Log pushd ../score
        flog $Log pact $Args generate
        flog $Log popd

        if ("$Tgts" == "") then
           NoteD $Log "Building PACT for $PSY_ID ($Msg) ..."
           NoteD $Log "Using C Compiler $PACT_CC_EXE ($PACT_CC_FAMILY)"

           flog $Log $DSYS linstall
           flog $Log pushd ..

           flog $Log setenv SESSION_CONFIG $PSY_ID
           flog $Log setenv PACTRoot $cwd

           flog $Log setenv  SC_EXEC_SERVER_WAIT     300
           flog $Log setenv  SC_EXEC_TIME_LIMIT      3600
           flog $Log setenv  SC_EXEC_TIME_FACTOR     80
           flog $Log setenv  SC_EXEC_TIME_THRESHOLD  120

           Note $Log "pact -log $Log -f $EtcDir/Makefile $Args build"
           pact -log $Log -f $EtcDir/Makefile $Args build
           set RStatus = $status

           flog $Log popd
        else
           NoteD $Log "Building packages for $PSY_ID ($Msg) ..."
           NoteD $Log ""
           flog $Log @ lerr = 0
           while ($#Tgts > 0)
              set tgt = $Tgts[1]
              shift Tgts
              if (-d $PSY_Base/$tgt) then
                 flog $Log pushd $PSY_Base/$tgt

                 NoteD $Log "$PSY_Base/$tgt"
                 flog $Log $PACT $Args install
                 flog $Log @ lerr = $lerr + $status
                 NoteD $Log ""

                 flog $Log popd
              endif
           end
           set RStatus = $lerr
        endif

        Note $Log "Build exit status = $RStatus"
        flog $Log pushd ../doc
        flog $Log pact install
        flog $Log popd

# fix up cross compile executables that need to run on the current host
# some things should be on the back end for testing
# but some need to be used by the system on the front end
# see score/make-wrap
        if ("$CROSS_REF" != "none") then
           NoteD $Log ""
           Separator $Log
           NoteD $Log "Cross compile fixes"
           set srcb = $CROSS_REF/bin
	   if ($srcb != $BinDir) then
              set CrossFix = ( hserve mpi-io-wrap )
#              set CrossFix = ( $CrossFix ps-diff png-diff )
              foreach i ( $CrossFix )
                 set exe = $srcb/$i
                 if (-x "$exe") then
                    NoteD $Log "   $exe"
                    flog $Log cp $exe ${BinDir}
                 endif
              end
           endif
	   unset srcb
           NoteD $Log "done"
        endif

        set ETime = `$TIMER -b $BeginTime`

        NoteD $Log ""
        Separator $Log
        if ($RStatus != 0) then
           foreach i (../*/$PSY_TmpDir/obj/errlog)
              if (!(-z $i)) then
                 flog $Log cat $i
              endif
           end
           NoteD $Log "PACT build for $PSY_ID failed ($RStatus/$ETime)"
           NoteD $Log "Check log file: ../dev/$PSY_ID/log/build"
        else
           NoteD $Log "PACT build for $PSY_ID complete ($ETime)"
        endif

        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case load:
        echo ""

        InitLog Log $LogDir/load

        flog $Log ( where pact |& head -n 1 )

#        set Args = "-dbg"
        set Args = ""
        set Tgts = ""
        while ($#argv > 0)
           switch ($1)
              case -a :
                   ./bpc $argv
                   exit($status)
                   breaksw
              case -dbg :
                   set Args = ( $Args $1 )
                   breaksw
              case -h :
                   echo ""
                   echo "Usage: dsys build [-a] [-h] [-na #] [-p #] [-s] [-u] [tgts]*"
                   echo ""
                   echo "     a  - build all current configurations"
                   echo "     h  - this help message"
                   echo "     na - number of attempts when commands fail"
                   echo "     p  - number of nodes to use"
                   echo "     s  - build shared libraries if configured"
                   echo "     u  - build static libraries only (default)"
                   echo ""
                   exit(1)
                   breaksw
              case -na :
                   shift
                   set Args = ( $Args +na $1 )
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -s :
                   shift
                   set MTgt = shared
                   breaksw
              case -u :
                   shift
                   set MTgt = build
                   breaksw
              case -o :
                   shift
                   breaksw
              case -* :
                   set Args = ( $Args $argv )
                   breaksw
              default :
                   set Tgts = ( $Tgts $1 )
                   breaksw
           endsw
           shift
        end

        flog $Log umask

        set BeginTime = `$TIMER -r`

        if ("$Tgts" == "") then
           NoteD $Log "Linking PACT on $hsy_host ..."

           flog $Log pushd ..
           flog $Log setenv SESSION_CONFIG $PSY_ID
           flog $Log setenv PACTRoot $cwd

           flog $Log setenv  SC_EXEC_SERVER_WAIT     300
           flog $Log setenv  SC_EXEC_TIME_LIMIT      3600
           flog $Log setenv  SC_EXEC_TIME_FACTOR     80
           flog $Log setenv  SC_EXEC_TIME_THRESHOLD  120
           Note $Log "pact -log $Log -f $EtcDir/Makefile $Args link"
           pact -log $Log -f $EtcDir/Makefile $Args link
           set RStatus = $status
           set Build   = "link"

           flog $Log popd
        else
           NoteD $Log "Linking packages on $hsy_host ..."
           NoteD $Log ""
           while ($#Tgts > 0)
              set tgt = $Tgts[1]
              shift Tgts
              if (-d $PSY_Base/$tgt) then
                 flog $Log pushd $PSY_Base/$tgt

                 NoteD $Log "$PSY_Base/$tgt"
                 flog $Log $PACT $Args link
                 NoteD $Log ""

                 flog $Log popd
              endif
           end
           set RStatus = $status
           set Build   = "packages"
        endif

        set ETime = `$TIMER -b $BeginTime`

        if ($RStatus != 0) then
           Note $Log "Link failed - some hints may be found in the files:"
           flog $Log ls -l ../*/$PSY_TmpDir/obj/errlog
        endif

        NoteD $Log ""
        NoteD $Log "PACT $Build on $hsy_host complete ($RStatus/$ETime)"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case clean:
        InitLog Log $LogDir/clean

        flog $Log ( where pact |& head -n 1 )

        set Args = "-i"
        while ($#argv > 0)
           switch ($1)
              case -h :
                   echo ""
                   echo "Usage: dsys clean [-h] [-p #]"
                   echo ""
                   echo "     h  - this help message"
                   echo "     p  - number of nodes to use"
                   echo ""
                   exit(1)
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -* :
                   breaksw
           endsw
           shift
        end

        NoteD $Log ""
        NoteD $Log "Cleaning Up PACT Directories ... "
        NoteD $Log ""

        flog $Log touch foo~ foo.log
        flog $Log $RM $Tmp.mk pact *~ core *.log

        flog $Log pushd ..
        pact -log $Log $Args -cmd $PCKS pact -i clean
        set RStatus = $status

        NoteD $Log ""
        NoteD $Log "done"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case commit:
        pact-commit $argv
        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case config:
        if (!(-x /bin/true) && !(-x /usr/bin/true)) then
           echo "ERROR: /bin/true not executable - exiting"
           exit(1)
        endif

        if ($?USER == 0) then
           if ($?LOGNAME == 0) then
              set USER = "anonymous"
           else
              set USER = $LOGNAME
           endif
        endif

        set ldof = partial

        set DoingConfig = TRUE

# do not let the current environment dictate compiler choices
        unsetenv Bits
        unsetenv HSY_CPU
        unsetenv HAVE_ANSI_C9X_COMPLEX
        unsetenv HAVE_READLINE
        unsetenv PACT_CC_FAMILY
        unsetenv PACT_CC_EXE
        unsetenv PACT_CC_VERSION
        unsetenv PACT_CC_PATH
        unsetenv PACT_FC_FAMILY
        unsetenv PACT_FC_EXE
        unsetenv PACT_FC_VERSION
        unsetenv PACT_FC_PATH
        unsetenv SMP_Pthread

        unsetenv Z_Inc
        unsetenv X11_Inc
        unsetenv PNG_Inc
        unsetenv JPEG_Inc
        unsetenv MDG_Inc

# do not bother with core files for the many analyzers
        limit coredumpsize 0 >& /dev/null

        setenv PSY_CONFIG_PATH ""
        if ($?PSY_SITE == 1) then
           set lsite = `echo $PSY_SITE | tr "[A-Z]" "[a-z]"`
           setenv PSY_CONFIG_PATH  "$PSY_CONFIG_PATH local/$lsite"
           unset lsite
        endif
        setenv PSY_CONFIG_PATH  "$PSY_CONFIG_PATH local std"

	setenv USE_LDLibPath ""

        setenv CCompiler  gnu

        setenv PSY_Arch  `$PSY_ScrDir/system-id`
        setenv Bits      `$PSY_ScrDir/nbit -d`

        set Configuration = ""
        set method        = 2
        set cross_ref     = none
        set reconfig      = FALSE
        set mpi           = FALSE
        set python        = FALSE
        set shared        = FALSE
        set openmp        = FALSE
        set platform      = FALSE
        set pthread       = FALSE
        set pydir         = ""
        set pyexe         = "python"
        set flst          = ""
        set dbcfg         = ""
        set ucfg          = ""

        set HelpCode      = ./$0
        set WhoIAm        = $USER

        set SCSRepository = ""
        set SRCDate       = ""
 
        set Opt   = "$HelpCode:t  $argv"
        set PArgs = ""

# save a copy of the args for the log
        set nargs = ( $argv )

        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   setenv SESSION_CONFIG $1
#                   $PSY_CfgMan add $1 >& /dev/null
                   breaksw
              case -as:
                   set PArgs = ( $PArgs "-as" )
                   breaksw
              case -b:
                   shift
                   setenv Bits $1
                   breaksw
              case -cc:
                   shift
                   setenv CCompiler  $1
                   $PSY_MngDir/verify-cc $CCompiler
                   if ($status != 0) then
                      exit(1)
                   endif
                   breaksw
              case -c:
                   set PArgs = ( $PArgs "-c" )
                   breaksw
              case -db:
                   shift
                   if ("$1" =~ /*) then
                      set dbcfg = $1
                   else
                      set dbcfg = $cwd/$1
                   endif
                   if (-f $dbcfg) then
                      pushd $dbcfg:h >& /dev/null
                      set dbcfg = $cwd/$dbcfg:t
                      popd >& /dev/null
                   endif
                   breaksw
              case -epy:
                   shift
                   set pyexe  = $1
                   set python = TRUE
                   breaksw
              case -f:
                   shift
                   setenv PSY_CONFIG_PATH   "$1 $PSY_CONFIG_PATH"
                   breaksw
              case -F:
                   set PArgs = ( $PArgs "-F" )
                   breaksw
              case -feature:
              case -features:
                   shift
                   set flst = ( $flst $1 )
                   breaksw
              case -g:
                   set ldof  = debug
                   set PArgs = ( $PArgs "-g" )
                   breaksw
              case -gsys:
                   shift
                   switch ("$1")
                      case gl:
                           setenv GRAPHICS_UseOGL TRUE
                           breaksw
                      case qd:
                           setenv GRAPHICS_UseQD  TRUE
                           breaksw
                      case x11:
                           setenv GRAPHICS_UseX  TRUE
                           breaksw
                   endsw
                   breaksw
              case -h:
                   echo ""
                   echo "Usage: dsys config [-a <sid>] [-as] [-b 32 | 64] [-c] [-db <db>]"
                   echo "                   [-f <directory>] [-F] [-feature <feature>] [-g]"
                   echo "                   [-gsys <opt>] [-h] [-i <directory>] [-llp <path>] [-o] [-O]"
                   echo "                   [-p] [-cc <C compiler>] [-py] [-s] [-sl] [-t] [-v] [<config>]"
                   echo ""
                   echo "        -a         set the system id for this config"
                   echo "        -as        do parts of config asynchronously"
                   echo "        -c         create missing directories for -i option"
                   echo "        -db        configure from specified database"
                   echo "        -f         a directory containing your configuration file"
                   echo "        -F         do fast builds using /tmp"
                   echo "        -g         build an absolutely debuggable version"
                   echo "        -gsys      use specified graphics system"
                   echo "                   options are: gl (OpenGL), qd (Apple Quickdraw), and x11 (default)"
                   echo "        -h         this help message"
                   echo "        -i         base installation directory (default /usr/local)"
                   echo "                   to omit installation use "-i none""
                   echo "        -llp       use <path> for LD_LIBRARY_PATH when analyzing compilers"
                   echo "                   special value '.' for path computed from compiler location (old default)"
                   echo "        -o         build an absolutely optimizied version"
                   echo "        -O         build an mixed debuggable/optimizied version"
                   echo "        -p         build a profiling version"
                   echo "        -strict    fail if exactly specified features are not found"
                   echo "        -v         display the Version of the Source Control System"
                   echo "        -V         configuration/build makefiles verbose"
                   echo ""
                   echo "   The following options apply only if no config file is specified:"
                   echo "        -b         size of pointers in bits for platforms with option"
                   echo "                   the default is determined by the platform defaults"
                   echo "        -cc        specify the compiler set to be used (default gnu)"
                   echo "                   use only when compilers from multiple vendors are"
                   echo "                   available on your system"
                   echo "                   use your PATH variable to select among multiple"
                   echo "                   installed versions of a single vendors compilers"
                   echo "                   a partial list of available compilers/platforms:"
                   echo "                      clang       CLANG compilers"
                   echo "                      intel       Intel compilers"
                   echo "                      gnu         GNU compilers"
                   echo "                      open64      Open64 compilers"
                   echo "                      path        PathScale compilers"
                   echo "                      pgi         PGI compilers"
                   echo "                      sun         SUN compilers"
                   echo "                   the following are multi-platform configurations for"
                   echo "                   cross build situations and are safe:"
                   echo "                      mp-gnu-bgl    GNU for IBM BG/L frontend and backend"
                   echo "                      mp-gnu-bgp    GNU for IBM BG/P frontend and backend"
                   echo "                      mp-gnu-bgq    GNU for IBM BG/Q frontend and backend"
                   echo "                      mp-gnu-cxe    GNU for CRAY XE frontend and backend"
                   echo "                      mp-gnu-win-64 GNU frontend and MinGW Win64 backend"
                   echo "                      mp-pgi-cxe    PGI for CRAY XE frontend and backend"
                   echo "                      mp-xlc-bgl    XLC for IBM BG/L frontend and backend"
                   echo "                      mp-xlc-bgp    XLC for IBM BG/P frontend and backend"
                   echo "                      mp-xlc-bgq    XLC for IBM BG/Q frontend and backend"
                   echo "                   the following are risky since they may refer to a frontend"
                   echo "                   build you do not have or control:"
                   echo "                      gnu-bgl     GNU for IBM BG/L backend only"
                   echo "                      gnu-bgp     GNU for IBM BG/P backend only"
                   echo "                      gnu-bgq     GNU for IBM BG/Q backend only"
                   echo "                      gnu-cxe     GNU for CRAY XE backend only"
                   echo "                      pgi-cxe     PGI for CRAY XE backend only"
                   echo "                      win-64      MinGW for Win64 backend"
                   echo "                      xlc-bgl     XLC for IBM BG/L backend only"
                   echo "                      xlc-bgp     XLC for IBM BG/P backend only"
                   echo "                      xlc-bgq     XLC for IBM BG/Q backend only"
                   echo "        -epy       full path python executable, implies -py"
                   echo "                   may be comma delimited list of executables"
                   echo "        -feature   <feature>[,<feature>]*"
                   echo "                   look in pact/manager/features for available features"
                   echo "        -mpi       build MPI version (equivalent to -feature mpi)"
                   echo "        -py        build python bindings (equivalent to -feature python)"
                   echo "        -s         build OpenMP version (equivalent to -feature openmp)"
                   echo "        -sl        build shared libraries (equivalent to -feature shared)"
                   echo "        -t         build threaded version (equivalent to -feature pthread)"
                   echo ""
                   echo "   Config files are optional and should be used to exercise"
                   echo "   more control than is available from the command line options"
                   echo "        <config>   the configuration for the installation"
                   echo "                   sample configs (see manager/std) are:"
                   echo "                        -    auto-aix     IBM RS6000 systems"
                   echo "                        -    auto-darwin  Mac OS X systmes"
                   echo "                        -    auto-hp      HP RISC 700 systems"
                   echo "                        -    auto-irix64  64 bit SGI systems running IRIX64 6.x"
                   echo "                        -    auto-linux   LINUX systems"
                   echo "                        -    auto-osf     OSF systems"
                   echo "                        -    auto-sol     Sun Solaris systems"
                   echo "                   (check manager/local for any local configs)"
                   echo ""
                   exit(1)
                   breaksw
              case -i:
                   shift
                   if (("$1" == none) || ("$1" =~ /*)) then
                      set PArgs = ( $PArgs "-i" $1 )
                   else
                      set PArgs = ( $PArgs "-i" $cwd/$1 )
                   endif
                   breaksw
# NOTE: use -epy instead (kept for backward compatibility)
              case -ipy:
                   shift
                   set pydir  = $1
                   set python = TRUE
                   breaksw
              case -llp:
                   shift
                   setenv USE_LDLibPath "-l $1"
                   breaksw
              case -md:
                   shift
                   set method = $1
                   breaksw
              case -mpi:
                   set mpi = TRUE
                   breaksw
              case -O:
                   set ldof = mixed
                   breaksw
              case -o:
                   set ldof  = optimize
                   set PArgs = ( $PArgs "-o" )
                   breaksw
              case -p:
                   set PArgs = ( $PArgs "-p" )
                   breaksw
              case -plt:
                   shift
                   set cross_ref = $1
                   set platform  = TRUE
                   breaksw
              case -py:
                   set python = TRUE
                   breaksw
              case -r:
                   set reconfig = TRUE
                   breaksw
              case -s:
                   set openmp = TRUE
                   breaksw
              case -sl:
                   set shared = TRUE
                   breaksw
              case -strict:
                   shift
                   set PArgs = ( $PArgs "-strict" $1 )
                   breaksw
              case -t:
                   set pthread = TRUE
                   breaksw
              case -v*:
                   source pact-scs
                   echo "  Source Version:   " $SCSVersion
                   echo "  Software Release: " $SCSRelease
                   echo ""
                   exit(1)
              case -V:
                   set PArgs = ( $PArgs "-v" )
                   breaksw
              default:
                   set Configuration = $1
           endsw
           shift
        end

        unsetenv LD_LIBRARY_PATH

        set BeginTime = `$TIMER -r`

# provide context for child processes
        setenv DSYS_TARGET pact_config

# set the configuration for this system
        setenv PSY_ID    `$PSY_CfgMan use`
        setenv PSY_Root  $DevDir/$PSY_ID

# now that we have the system, reset the variables that depend on it
        set LogDir  = $PSY_Root/log
        set IncDir  = $PSY_Root/include
        set EtcDir  = $PSY_Root/etc
        set BinDir  = $PSY_Root/bin
        set LibDir  = $PSY_Root/lib
        set PACT    = $BinDir/pact

        setenv PERDB  $BinDir/perdb
        setenv GEXEC  $BinDir/gexec

        set EnvCsh = $EtcDir/env-pact.csh
        set EnvSh  = $EtcDir/env-pact.sh

        set temp   = $SHELL
        set CurrSh = $temp:t
        setenv CURR_SH $CurrSh

# source control system variables
        source pact-scs

# set up some items in the working environment
        set path = ( . $BinDir $PSY_ScrDir $path )

        setenv HSY_OS_Name  `uname -s`

# make sure the log directory is there - do not wait for later
        if (!(-d $LogDir)) then
           mkdir -p $LogDir
        endif
        if (!(-d $PSY_Root/log)) then
           flog $Log mkdir $PSY_Root/log
        endif

        InitLog Log $LogDir/config

        Note $Log "Args            = $nargs"
        if ($?SESSION_CONFIG == 1) then
           Note $Log "SESSION_CONFIG  = $SESSION_CONFIG"
        endif
        Note $Log "PSY_ID          = $PSY_ID"
        Note $Log "PSY_SITE        = $PSY_SITE"
        Note $Log "PSY_AIRoot      = $PSY_AIRoot"
        Note $Log "PSY_ASRoot      = $PSY_ASRoot"
        Note $Log "PSY_Root        = $PSY_Root"
        Note $Log "PSY_CONFIG_PATH = $PSY_CONFIG_PATH"

        flog $Log umask

# make sure that the installation directories exist
        if (!(-d $DevDir)) then
           flog $Log mkdir $DevDir
        endif
        if (!(-d $PSY_Root)) then
           flog $Log mkdir $PSY_Root
        endif
        if (!(-d $PSY_Root/bin)) then
           flog $Log mkdir $PSY_Root/bin
        endif
        if (!(-d $PSY_Root/lib)) then
           flog $Log mkdir $PSY_Root/lib
        endif
        if (!(-d $PSY_Root/include)) then
           flog $Log mkdir $PSY_Root/include
        endif
        if (!(-d $PSY_Root/include/shell)) then
           flog $Log mkdir $PSY_Root/include/shell
        endif
        if (!(-d $PSY_Root/etc)) then
           flog $Log mkdir $PSY_Root/etc
        endif
        if (!(-d $PSY_Root/man)) then
           flog $Log mkdir $PSY_Root/man
        endif
        if (!(-d $PSY_Root/man/man1)) then
           flog $Log mkdir $PSY_Root/man/man1
        endif
        if (!(-d $PSY_Root/man/man3)) then
           flog $Log mkdir $PSY_Root/man/man3
        endif
        if (!(-d $PSY_Root/scheme)) then
           flog $Log mkdir $PSY_Root/scheme
        endif
        if (!(-d $PSY_Root/scheme/extensions)) then
           flog $Log mkdir $PSY_Root/scheme/extensions
        endif

        flog $Log $RM *.core *~
        flog $Log $RM $LogDir/analyze*

# figure out from where configuration info is coming
        set gdir = gen/$PSY_Arch
        if (!(-d $gdir)) then
           flog $Log mkdir -p $gdir
        endif
        if ($reconfig == FALSE) then
           flog $Log rm -f $gdir/$Configuration
        endif

# if using a database do the location/generation steps
        if ("$dbcfg" != "") then
           NoteD $Log "Using database $dbcfg to configure this PACT installation."

           if (-f $dbcfg) then
#              set ndbcfg = $cwd/$gdir/$PSY_ID.cfg
              flog $Log set ndbcfg = $EtcDir/$PSY_ID.cfg
              if ($dbcfg != $ndbcfg) then
                 flog $Log cp $dbcfg $ndbcfg
              endif
              flog $Log set dbcfg = $ndbcfg
              unset ndbcfg
           else
              NoteD $Log "No such database '$dbcfg' - exiting"
              exit(1)
           endif

# if using a file or generated config
        else
           Note $Log "Original feature list: $flst"
           Note $Log "Original config file: $Configuration"

# if no configuration is specified - generate from scratch
           if ("$Configuration" == "") then
              call GEN_CONFIG()
              flog $Log set cmod = "command line options"
              flog $Log set ucfg = $gdir/$Configuration
              flog $Log set dir  = $gdir

# if file exists as is use it
           else if (-f $Configuration) then
              flog $Log set cmod = "full path file"
              flog $Log set ucfg = $gdir/$Configuration
              flog $Log set dir  = $gdir

# otherwise look in the configs directories for the root and build it
           else
              set inf   = ( `gen-cfg-root -r $Configuration` )
              set croot = $inf[1]
              if ($#inf > 1) then
                 set flst  = ( $flst $inf[2-] )
              endif
              if ($croot == none) then
                 flog $Log set cmod = "existing file"
                 flog $Log set ucfg = $gdir/$Configuration
                 flog $Log set dir  = $gdir
              endif
              unset inf
              unset croot
           endif
   
# remove duplicate features and take care of Bits
           set nflst = ""
           foreach f ($flst)
              if (($f == 64) || ($f == 32)) then
                 flog $Log setenv Bits $f
              else
                 set ok = TRUE
                 foreach l ($nflst)
                    if ($f == $l) then
                       set ok = FALSE
                       break
                    endif
                 end
                 if ($ok == TRUE) then
                    set nflst = ( $nflst $f )
                 endif
              endif
           end
           set flst = ( $nflst )
           unset ok

           Note $Log "Final feature list: $flst"

# if there still is no config file - generate from what we know
           if ("$ucfg" == "") then
              flog $Log set cmod = "generated file"
              flog $Log set ucfg = `gen-cfg $Configuration`
              flog $Log set dir  = $gdir
           endif
           NoteD $Log ""
           NoteD $Log "Configuring from $ucfg ($cmod)"
           unset gdir
        endif

        set RStatus = 0

        flog $Log pushd ../psh
        flog $Log unsetenv LD_LIBRARY_PATH
        flog $Log ./ccw -g pco.c -o $BinDir/pco
        if ($status == 0) then
           flog $Log ./ccw -g -DPSY_Prefix=\"${PSY_Prefix}\" do-run.c -o $BinDir/do-run
           flog $Log ./ccw -g perdb.c -o $BinDir/perdb
           flog $Log ./ccw -g gexec.c -o $BinDir/gexec
           flog $Log ./ccw -g elide.c -o $BinDir/elide
           flog $Log ./ccw -g blang.c -o $BinDir/blang
           flog $Log ./ccw -g -I../score -I../manager template.c -o $BinDir/template
        else
           NoteD $Log ""
           NoteD $Log "Failed to build pco utility - exiting"
           NoteD $Log ""
           exit(1)
        endif

        flog $Log popd

# remove standard Tool and Group variables from the environment
        foreach v ( `env |& sed 's|^[ \t].*||' | sed 's|=.*$||'` )
           switch ($v)
              case CC_*:
              case FC_*:
              case LD_*:
              case Std_*:
              case Cfg_*:
              case Cfe_*:
                   unsetenv $v
           endsw
        end

        Separator $Log

# setup for PERDB session
        flog $Log setenv PERDB_IDLE_TIMEOUT 600
        flog $Log setenv PERDB_IDLE_INTERVAL 10
        flog $Log setenv PERDB_PATH $EtcDir/cfg
        flog $Log set dbopt = ( -f $PERDB_PATH )

# NOTE: a dsys reconfig will launch a server so kill any running
# servers and do dsys config with a clean slate
# perdb quit: can hang if the connection is already gone so avoid this
# perdb will quit if the connection goes but it may take awhile so
# lags are a problem
        if (0) then
           flog $Log $PERDB -l quit:
           while (-f $PERDB_PATH.conn)
              sleep 1
           end
        else
           flog $Log ls -l ${PERDB_PATH}*
           Note $Log "Checking for running perdb servers"
           if (-f $PERDB_PATH.conn) then
              set linf = ( `cat $PERDB_PATH.conn |& sed 's|[^a-zA-Z0-9]|x|g'` )
              set lpid = "$linf[$#linf]"
              Note $Log "   pid = $lpid"
              flog $Log (ps -ef | grep $lpid | grep perdb)
              if ($status == 0) then
                 flog $Log kill -9 $lpid
              endif
              unset lpid
              unset linf
           else
              Note $Log "   none found"
           endif
        endif
        flog $Log $RM ${PERDB_PATH}*
        sleep 1
        flog $Log $PERDB -l -c -s
        sleep 1
        flog $Log ls -l ${PERDB_PATH}*

        flog $Log set PCO = ( $BinDir/pco $dbopt -env $PSY_MngDir/pact.env -l )

        Separator $Log
        dbset PSY_Dbg_Opt  $ldof
        dbset PACT_VERSION $PACTVer
	if ($platform == TRUE) then
           dbset CROSS_REF $cross_ref
        endif

# start the env files
        $RM $EnvCsh
        touch $EnvCsh
        Note $EnvCsh ""
        Note $EnvCsh "setenv PSY_ID $PSY_ID"
        Note $EnvCsh "set path   = ( . $DevDir/"'$PSY_ID/bin $path )'
        Note $EnvCsh ""

        $RM $EnvSh
        touch $EnvSh
        Note $EnvSh ""
        Note $EnvSh "export PSY_ID=$PSY_ID"
        Note $EnvSh "export PATH=.:$DevDir/"'$PSY_ID/bin:$PATH'
        Note $EnvSh ""

# remove files we are about to generate in include
# so that if generation fails we are not left with ghosts from old configs
        set GenFiles = ""
        set GenFiles = ( $GenFiles f90-interface )
        set GenFiles = ( $GenFiles iso-c.h scconfig.h scdecls.h syntax.h)
        set GenFiles = ( $GenFiles spokes.scm )
        foreach i ( $GenFiles )
           flog $Log $RM $IncDir/$i
        end

# remove files we are about to generate in etc
# so that if generation fails we are not left with ghosts from old configs
        set GenFiles = ""
        set GenFiles = ( $GenFiles package configured )
        set GenFiles = ( $GenFiles make-def make-macros Makefile )
        foreach i ( $GenFiles )
           flog $Log $RM $EtcDir/$i
        end

# remove files we are about to generate in bin
# so that if generation fails we are not left with ghosts from old configs
        set GenFiles = ""
        set GenFiles = ( $GenFiles install-pact )
        foreach i ( $GenFiles )
           flog $Log $RM $BinDir/$i
        end

# must have cpyright.h available during configuration
        flog $Log cp cpyright.h $IncDir

	if ("$flst" != "") then
           set PArgs = ( $PArgs -ft `echo $flst | sed 's| |-|g'` )
        endif

# do the main configuration work
        if ("$ucfg" != "") then
           Note $Log "Command: $PCO $PArgs -s $PSY_ID $ucfg"
           $PCO -s $PSY_ID $PArgs $ucfg
           set RStatus = $status

        else if ("$dbcfg" != "") then
           Note $Log "Command: $PCO -s $PSY_ID $PArgs -db $dbcfg"
           $PCO -s $PSY_ID $PArgs -db $dbcfg
           set RStatus = $status
           unset dbcfg

        else
           NoteD $Log "There is no $Configuration in $PSY_CONFIG_PATH"
           set RStatus = 3
        endif

        unset dir
        if ($RStatus != 0) then
           goto CFG_DONE
        endif

# now that PCO made us one, source it        
        source $EnvCsh

# cleanup path so as not to tax wimpy OSs such as Solaris
# and remove any extra pact version from the path
        eval `$PSY_ScrDir/simplify-path -p pact`

        flog $Log chmod a+x code-date
        flog $Log pwd

        flog $Log csh -f $DSYS linstall
        set RStatus = $status
        Note $Log "Status = $RStatus"
        if ($RStatus != 0) then
           NoteD $Log "   linstall failed during 'dsys config'"
           goto CFG_DONE
        endif

# settle on smake or dmake
        Separator $Log

# check for multi-platform build
        dbget PSY_Platforms
        if ("$PSY_Platforms" != "") then
           set inf = ( `echo "$PSY_Platforms" | sed 's|:| |g'` )
           @ np = $#inf
           Note $Log "$np added platforms"

           set lpact = ${BinDir}/pact
           set inf   = ( `echo "$inf" | sed 's|[()]| |g'` )

           @ ni = $#inf
           @ i  = 0
           while ($i < $ni)
              @ i = $i + 1
              set cfg = $inf[$i]
              @ i = $i + 1
              set sid = $inf[$i]

              set bind = $DevDir/$sid/bin

# set the main pact link to the first platform pact
              flog $Log pushd ${bind}
              flog $Log mv pact pact.cfg
              flog $Log ln -s $lpact pact
              flog $Log popd
           end
           unset lpact
           unset bind
           unset inf

# restore configuration
           if ($?SESSION_CONFIG == 1) then
              flog $Log set sid = $SESSION_CONFIG
              flog $Log unsetenv SESSION_CONFIG
           else
              flog $Log set sid = $PSY_ID
           endif
           flog $Log $PSY_CfgMan add $sid
           unset sid

        else
           if (!(-f $PERDB_PATH.db)) then
              NoteD $Log ""
              NoteD $Log "No configuration database '$PERDB_PATH.db' - fatal"
              NoteD $Log ""
              exit(1)
           else if (-z $PERDB_PATH.db) then
              NoteD $Log ""
              NoteD $Log "Zero length configuration database '$PERDB_PATH.db' - fatal"
              NoteD $Log ""
              exit(1)
           endif
        endif

# wrap it up
        Separator $Log

        flog $Log $PERDB -l quit:

        if ($platform == FALSE) then
           NoteD $Log ""
           NoteD $Log "Configuration for version $PACTVer complete (`$PSY_CfgMan use`)"
           NoteD $Log ""

           echo $cwd
           rehash

# create empty extensions directories if they don't exist already
           set ExtDirs = ( $PSY_Base/sx/applications/extensions $PSY_Base/ultra/applications/extensions )
           foreach d ($ExtDirs)
              if (-d $d:h) then
                 if (!(-d $d)) then
                    flog $Log mkdir $d
                 endif
              endif
           end

# figure out which shell you are using
           NoteD $Log ""
           NoteD $Log "Your shell is $CURR_SH.  Consequently, you should do:"
           NoteD $Log ""
           if (($CURR_SH != csh) && ($CURR_SH != tcsh)) then
              NoteD $Log "   . $EnvSh"
           else
              NoteD $Log "   source $EnvCsh"
           endif
           NoteD $Log ""
           NoteD $Log "into your current environment before proceeding to do work"
           NoteD $Log "on the PACT system not covered by the installation process."

           set ETime = `$TIMER -b $BeginTime`

           NoteD $Log ""
           NoteD $Log "PACT configured ($RStatus/$ETime)"
           NoteD $Log ""
        endif

CFG_DONE:
        unset dbopt

        if ($?SESSION_CONFIG == 1) then
           Note $Log "Leaving with:"
           Note $Log "   SESSION_CONFIG  = $SESSION_CONFIG"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case configured:

        while ($#argv > 0)
           switch ($1)
              case -a:
                   set db  = $EtcDir/cfg.db
                   set inf = ( `pact +l -info RF_CONFIG_METHOD` )
                   set mth = $inf[1]
                   set cfg = ( `grep PSY_Cfg= $db | sed 's/^PSY_Cfg=//'` )
                   set inf = ( `$PSY_CfgMan list` )
                   set cur = ( `$PSY_CfgMan use` )
                   echo "Configuration list:    $inf"
                   echo "Current configuration: $cur"
                   echo "Current config file:   $cfg"
                   echo "Current config method: $mth"
                   exit(0)
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo 'Usage: dsys configured [-a] [-h]'
                   echo ""
                   echo "   a      - show config name and sid"
                   echo "   h      - this help message"
                   echo ""
                   exit(1)
                   breaksw
           endsw
           shift
        end

        cat $EtcDir/configured
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case delete:

        InitLog Log $LogDir/delete

        set Cfgs = ""
        while ($#argv > 0)
           switch ($1)
              case -a:
                   foreach i ($DevDir/*)
                      set c = $i:t
                      if ("$c" =~ *+*) then
                         set Cfgs = ( $Cfgs $c )
                      else if ($c =~ *none*) then
                         set Cfgs = ( $Cfgs $c )
                      else
                         set spec = `echo $c | sed 's/+/ /'`
                         Note $Log "spec = $spec"
                         if ($#spec > 1) then
                            set cfg   = $spec[2]
                            set iscfg = `find . -name $cfg`
                            Note $Log "   Cfg : |$cfg| |$iscfg|"
                            if ("$iscfg" != "") then
                               set hst   = $spec[1]
                               set ishst = `host $hst | awk '{ print $1 }'`
                               Note $Log "   Host: |$hst| |$ishst| |$hsy_host|"
                               if ("$ishst" != "Host") then
                                  set Cfgs = ( $Cfgs $c )
                               else
                                  set ishst = `host $hst-pub | awk '{ print $1 }'`
                                  if ("$ishst" != "Host") then
                                     set Cfgs = ( $Cfgs $c )
                                  endif
                               endif
                            endif
                         endif
                      endif
                   end
# NOTE: we are about to wipe out the log file and directory if this
# is being done from do-pact
                   set Log = /dev/null
                   break
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo 'Usage: dsys delete [-a] [-h] <config>*'
                   echo ""
                   echo "   a      - delete all multiconfig type configurations"
                   echo "   h      - this help message"
                   echo ""
                   exit(1)
                   breaksw
              default:
                   set Cfgs = ( $Cfgs $1 )
                   breaksw
           endsw
           shift
        end

        foreach c ($Cfgs)
           Separator $Log
           NoteD $Log -n "Deleting configuration $c ... "
           Note $Log ""

           flog $Log pwd
           flog $Log $PSY_CfgMan delete $c

           find .. -name "*$c" -type d |& grep -v '\.pc' |& xargs rm -rf
           set RStatus = $status

           NoteD $Log "done"
        end

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case diff-hdrs:
        InitLog Log $LogDir/diff-hdrs

        flog $Log ( where pact |& head -n 1 )

        set Args = "-i"
        while ($#argv > 0)
           switch ($1)
              case -h :
                   echo ""
                   echo "Usage: dsys diff-hdrs [-h] [-p #]"
                   echo ""
                   echo "     h  - this help message"
                   echo "     p  - number of nodes to use"
                   echo ""
                   exit(1)
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -* :
                   breaksw
           endsw
           shift
        end

        NoteD $Log ""
        NoteD $Log "Reporting PACT Changes ..."
        NoteD $Log ""

        flog $Log pushd ..
        pact -log $Log $Args -cmd $PCKS pact diff-hdr
        set RStatus = $status

        NoteD $Log ""
        NoteD $Log "done"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case dirs:

        if (!(-d $DevDir)) then
           mkdir $DevDir
        endif
        if (!(-d $PSY_Root)) then
           mkdir $PSY_Root
        endif
        if (!(-d $PSY_Root/bin)) then
           mkdir $PSY_Root/bin
        endif
        if (!(-d $PSY_Root/lib)) then
           mkdir $PSY_Root/lib
        endif
        if (!(-d $PSY_Root/include)) then
           mkdir $PSY_Root/include
        endif
        if (!(-d $PSY_Root/etc)) then
           mkdir $PSY_Root/etc
        endif
        if (!(-d $PSY_Root/scheme)) then
           mkdir $PSY_Root/scheme
        endif
        if (!(-d $PSY_Root/scheme/extensions)) then
           mkdir $PSY_Root/scheme/extensions
        endif
        if (!(-d $PSY_Root/log)) then
           mkdir $PSY_Root/log
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case dist:
        $Time ./pact-dist $argv
        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case force-install:

        set cfgs = ""
        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys force-install -h <cfg>*"
                   echo "    h   - this help message"
                   exit(1)
                   breaksw
              default:
                   set cfgs = ( $cfgs $1 )
                   breaksw
           endsw
           shift
        end

        foreach c ($cfgs)
           echo -n "   $c ... "
           setenv SESSION_CONFIG $c
           source ../dev/$SESSION_CONFIG/etc/env-pact.csh
           rehash
           install-pact >& /dev/null
           set RStatus = $status
           if ($RStatus == 0) then
              echo "ok"
           else
              echo "ng"
           endif
        end

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case import:
        ./pact-import $argv
        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case info:
        set HelpCode  = $PSY_MngDir/$0
        set SCSOpt    = ""

        set SCSRepository = ""
        set SRCDate       = ""

        set All = "seld"

        set ROOT    = `where smake |& head -n 1`
        set BINDIR  = $ROOT:h
        set RepoDir = ""
        set SrcDir  = ""
        set BinDir  = ""
        set LibDir  = ""
        set IncDir  = ""
        set EtcDir  = ""
        set MgrDir  = ""
        set DocDir  = ""
        set Man1Dir = ""
        set Man3Dir = ""
        set Tags    = ""
        set ChkVer  = ""

        while ($#argv > 0)
           set All = ""
           switch ($1)
              case -c:
              case log:
                   shift

# check that these sources are checked out rather than
# from a distribution
                   scs-meta -k >>& /dev/null
                   if ($status == 0) then
                      set RepoDir = `scs-meta -r`
                      if ($#argv > 0) then
                         set Date = ""
                         while ($#argv > 0)
                            switch ($1)
                               case -d:
                                    shift
                                    set Date = `echo "$1" | sed 's|/|_|g' | sed 's|-|_|g'`
                                    breaksw
                               case -h:
                                    echo "Usage: dsys info -c [-h] [[-d <date>] <tag>]*"
                                    echo "  h  this help message"
                                    echo "  d  search for tags after <date>"
                                    echo "     <date> may be yy/mm/dd, yy-mm-dd, or yy_mm_dd"
                                    echo "  <tag> may be one of F, B, M, S, X"
                                    breaksw
                               default:
                                    git log
#                                    set Tag = "|$1|"
#                                    if ("$Date" == "") then
#                                       grep $Tag $RepoDir/commitlog
#                                    else
#                                       grep $Tag $RepoDir/commitlog    |&  \
#                                       sed "s/'//g"                    |&  \
#                                       sed 's/\"//g'                   |&  \
#                                       awk '$4 >= "D'$Date'" { print }'
#                                    endif
                                    set Date = ""
                                    breaksw
                            endsw
                            shift
                         end
                      else
                         echo ""
                         echo "PACT commit log:"
                         eval "more $RepoDir/commitlog"
                      endif

                      unset RepoDir
                   endif

                   break
                   breaksw

              case -h:
                   echo ""
                   echo " Usage: dsys info [-c] [-t] [-h] [-d] [-e] [-i] [-l] [-m] [-s] [-x]"
                   echo "        display info about the installed PACT"
                   echo "        by default display info for the sources, executables,"
                   echo "        libraries and documents"
                   echo ""
                   echo "    c    display the source repository commit log"
                   echo "         (this has suboption which may be seen with -c -h)"
                   echo "    t    display info for the Version Tags"
                   echo "    h    this help message"
                   echo "    d    display info for the documents"
                   echo "    e    display info for the executables"
                   echo "    i    display info for the include (header) files"
                   echo "    l    display info for the libraries"
                   echo "    m    display info for the manager script files"
                   echo "    s    display info for the source files"
                   echo "    x    report number of MBytes of source, libraries, and binaries"
                   echo ""
                   exit(1)
                   breaksw

              case -d:
                   set DocDir = $PSY_AIRoot/pact/docs
                   breaksw

              case -e:
                   set BinDir = "$BINDIR"
                   breaksw

              case -i:
                   set IncDir = ( "$BINDIR:h""/include" )
                   breaksw

              case -l:
                   set LibDir = ( "$BINDIR:h""/lib" )
                   breaksw

              case -m:
                   set MgrDir = "$PSY_MngDir"
                   breaksw

              case -s:
                   set SrcDir = $PSY_AIRoot/pact/wrk
                   breaksw

              case -t:
                   source $PSY_MngDir/pact-scs
                   set Tags = "-def"
                   breaksw

              case -x:
                   setenv PSY_ID    `$PSY_CfgMan use`
                   setenv PSY_Root  $DevDir/$PSY_ID
                   set IncDir = $PSY_Root/include
                   set Pck    = `cat $EtcDir/package`
                   pushd .. >& /dev/null
                   set NB = `du -sb $Pck manager python $PSY_Root | awk 'BEGIN {nb = 0;} {nb += $1} END {printf("%.1f", nb/(1024.0*1024.0));}'`
                   popd >& /dev/null
                   echo "Approximately $NB MB of sources, objects, libraries, and binaries"
                   exit(0)
                   breaksw

              case -v:
                   set ChkVer = "yes"
                   breaksw
           endsw
           shift
        end

        if ($All != "") then
           set SrcDir  = $PSY_AIRoot/pact/wrk
           set BinDir  = "$BINDIR"
           set LibDir  = ( "$BINDIR:h""/lib" )
           set IncDir  = ( "$BINDIR:h""/include" )
           set EtcDir  = ( "$BINDIR:h""/etc" )
           set Man1Dir = $PSY_AIRoot/pact/man/man1
           set Man3Dir = $PSY_AIRoot/pact/man/man3
           set DocDir  = $PSY_AIRoot/pact/docs
        endif

        set LS = 'ls -l'

        set Libs = ( `awk '$1 == "lib"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Incs = ( `awk '$1 == "inc"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Bins = ( `awk '$1 == "bin"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Scrs = ( `awk '$1 == "script" {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Mods = ( `awk '$1 == "f90"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Scms = ( `awk '$1 == "scm"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Docs = ( `awk '$1 == "doc"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Pact = ( `awk '$1 == "pkg"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )
        set Mgrs = ( `awk '$1 == "mgr"    {for (i = 2; i <= NF; i++) {printf("%s ", $i);};}' $PSY_MngDir/pact.manifest` )

        set ScrB = ( $Scrs )

        echo ""
        echo `date`
        echo ""

# SOURCES

        if ($SrcDir != "") then
           set STDOUT = $cwd/src.count
           $RM $STDOUT
           touch $STDOUT

           cd $SrcDir

           echo "PACT sources reside in $SrcDir"
           set CSrc = ""
           foreach i ($Pact)
              set CSrc = ( $CSrc `find $i -name "*.[ch]" | grep -v /$PSY_Prefix | grep -v /dev/` )
           end
           wc -l $CSrc     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines C source", $1 }' >>& $STDOUT
           echo " in $#CSrc files" >>& $STDOUT

           touch foobar
           set FSrc = ""
           foreach i ($Pact)
              set FSrc = ( $FSrc `find $i -name "*.f" | grep -v /$PSY_Prefix | grep -v /dev/` )
           end
           wc -l $FSrc     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines Fortran source", $1 }' >>& $STDOUT
           $RM foobar
           echo " in $#FSrc files" >>& $STDOUT

           set SSrc = ""
           set SSrc = ( $SSrc `find panacea -name "*.scm" | grep -v /$PSY_Prefix | grep -v /dev/` )
           set SSrc = ( $SSrc `find scheme -name "*.scm" | grep -v /$PSY_Prefix | grep -v /dev/` )
           set SSrc = ( $SSrc `find sx -name "*.scm" | grep -v /$PSY_Prefix | grep -v /dev/` )
           set SSrc = ( $SSrc `find ultra -name "*.scm" | grep -v /$PSY_Prefix | grep -v /dev/` )
           wc -l $SSrc     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines SCHEME source", $1 }' >>& $STDOUT
           echo " in $#SSrc files" >>& $STDOUT

           set PSrc = ""
           set PSrc = ( $PSrc `find manager -name "pre-Make"` )
           foreach i ($Pact)
              set PSrc = ( $PSrc `find $i -name "pre-Make"` )
           end
           wc -l $PSrc     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines pre-Make file", $1 }' >>& $STDOUT
           echo " in $#PSrc files" >>& $STDOUT

           cd manager
           wc -l $Mgrs     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines manager source", $1 }' >>& $STDOUT
           echo " in $#Mgrs files" >>& $STDOUT
           cd ..

           cd scripts
           wc -l $Scrs     |&                                                 \
           grep -v "wc:"   |                                                  \
           tail -n 1       |                                                  \
           awk '{ printf "%8d\tlines script source", $1 }' >>& $STDOUT
           echo " in $#Scrs files" >>& $STDOUT
           cd ..

           awk '    { lines = lines + $1                                      \
                      print }                                                 \
                END { printf "Total maintained source is %d lines\n", lines }' $STDOUT

           echo ""
           $RM $STDOUT
        endif

# EXECUTABLES

        if ($BinDir != "") then
           echo ""
           echo "PACT executables reside in $BinDir"
           cd $BinDir
           $LS $Bins |&                                                              \
           grep -v "ls:"   |                                                         \
           awk '    { bytes = bytes + $5                                             \
                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }             \
                END { printf "Total space for executables is %d bytes\n\n", bytes }'

           echo ""
           echo "PACT scripts reside in $BinDir"
           cd $BinDir
           $LS $ScrB |&                                                              \
           grep -v "ls:"   |                                                         \
           awk '    { bytes = bytes + $5                                             \
                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }             \
                END { printf "Total space for scripts is %d bytes\n\n", bytes }'
        endif

# LIBRARIES

        if ($LibDir != "") then
           echo ""
           echo "PACT libraries reside in $LibDir"
           cd $LibDir
           set NLibs = ""
           foreach lib ($Libs)
              set base = $lib:r
              set NLibs = ( $NLibs `ls $base*` )
           end
           $LS $NLibs | awk '    { bytes = bytes + $5                                                \
                                         printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }          \
                                   END { printf "Total space for libraries is %d bytes\n\n", bytes }'
        endif

# HEADERS

        if ($IncDir != "") then
           echo ""
           echo "PACT headers reside in $IncDir"
           cd $IncDir
           $LS $Incs | awk '    { bytes = bytes + $5                                              \
                                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }          \
                                END { printf "Total space for headers is %d bytes\n\n", bytes }'
        endif

# CONFIG INFO

        if ($EtcDir != "") then
           echo ""
           echo "PACT config files in $EtcDir"
           cd $EtcDir
           $LS $Etcs | awk '    { bytes = bytes + $5                                              \
                                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }          \
                                END { printf "Total space for configs is %d bytes\n\n", bytes }'
        endif

# SCRIPTS

        if ($MgrDir != "") then
           echo ""
           echo "PACT manager scripts reside in $MgrDir"
           cd $MgrDir
           $LS $Mgrs | awk '    { bytes = bytes + $5                                      \
                                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 }  \
                                END { printf "Total space for manager scripts is %d bytes (~%d lines)\n\n", bytes, bytes/26 }'
        endif

# MAN PAGES

        if ($Man1Dir != "") then
           echo ""
           echo "PACT man pages reside in $Man1Dir and $Man3Dir"
           cd $Man1Dir:h
           $LS man1/*.1 man3/*.3 | \
           awk '    { bytes = bytes + $5                                       \
                      printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 } \
                END { printf "Total space for man pages is %d bytes (~%d lines)\n\n", bytes, bytes/26 }'
        endif

# DOCS

        if ($DocDir != "") then
           echo ""
           echo "PACT FAQ files and postscript documents reside in $DocDir"
           cd $DocDir
           $LS $Docs | awk '    { bytes = bytes + $5                                       \
                                        printf "%8d\t%s %s %s\t%s\n", $5, $6, $7, $8, $9 } \
                                  END { printf "Total space for FAQ and ps docs is %d bytes (~%d pages)\n\n", bytes, bytes/3668 }'
        endif

# REPOSITORY
        if ("$Tags" != "") then
           echo ""
           echo "PACT revision tags:"
           eval "($PSY_ScrDir/scs-history $Tags | tail -n 20 )"
        endif

        if ($ChkVer == "yes") then
           echo ""
           echo "Version info for PACT:"
           set lmand = $PSY_AIRoot/pact/public/std/src/manager
           echo "   pact-date    =  `cat $lmand/.pact-date`" 
           echo "   pact-version =  `cat $lmand/.pact-version`" 
           echo "   pact-tag     =  `cat $lmand/.pact-version-tag`" 
           echo ""
           echo "Version info for PACTNEW:"
           set lmand = $PSY_AIRoot/pact/public/new/src/manager
           echo "   pact-date    =  `cat $lmand/.pact-date`" 
           echo "   pact-version =  `cat $lmand/.pact-version`" 
           echo "   pact-tag     =  `cat $lmand/.pact-version-tag`" 
        endif

        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case install:
 
        set Args = ""

        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   setenv SESSION_CONFIG $1
                   breaksw
              case -h:
              case help:
                   echo "Usage: dsys install [-a <sys>] [-h] [-p #]"
                   echo ""
                   echo "   a     do remove of configuration <sys>"
                   echo "   h     this help message"
                   echo "   p     do work in parallel"
                   echo ""
                   exit(1)
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
           endsw
           shift
        end

        set DevDir = $PSY_Base/dev

        setenv PSY_ID    `$PSY_CfgMan -d ../dev use`
        setenv PSY_Root  $DevDir/$PSY_ID

        set BinDir  = $PSY_Root/bin
        set EtcDir  = $PSY_Root/etc
        set LogDir  = $PSY_Root/log

        setenv GEXEC   $BinDir/gexec
        setenv PATH    ${BinDir}:${PATH}

        InitLog Log $LogDir/install

# do install for multi-platform configuration
        flog $Log setenv PERDB_PATH $EtcDir/cfg
        dbget PSY_Platforms
        if ("$PSY_Platforms" != "") then
           set Args = ( $Args -f $EtcDir/Makefile )

           set inf = ( `echo "$PSY_Platforms" | sed 's|:| |g'` )
           @ np = $#inf
           Note $Log "$np platforms"

           NoteD $Log ""

           flog $Log pushd ..
           ftee $Log pact $Args install
           flog $Log popd
        else
           ftee $Log install-pact
        endif
        set RStatus = $gstatus[1]

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case linstall:
        if (-e extensions/pre-Make) then
           pushd extensions >& /dev/null
           pact -sys . install
           popd >& /dev/null
        endif

        set InstF = ""
        set InstF = ( $InstF pact-update code-date )
        set InstF = ( $InstF install-ext )
        set InstF = ( $InstF ../scripts/{import-api,pcpp,px,frnsic,sinstall} )

# requiring pact-dist to be run from manager - no need to install
#        set InstF = ( $InstF pact-dist )

        set liu = ../scripts/sinstall

        @ lerr = 0

        $liu gdbinit $BinDir/.gdbinit
        @ lerr = $lerr + $status
        $liu dbxinit $BinDir/.dbxinit
        @ lerr = $lerr + $status
        $liu cpyright.h $IncDir
        @ lerr = $lerr + $status
        $liu $InstF $BinDir
        @ lerr = $lerr + $status

        set RStatus = $lerr

        unset liu
        unset lerr

        echo ""
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# NET-UPDATE - handle some of the boot-strapping issues for a successful
#            - do-net run

   case net-update:
        InitLog Log $LogDir/net-update

        set CArgs    = ""
        set DArgs    = ""
        set HostFile = ""
        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   set CArgs = "-a"
                   while ($#argv > 0)
                      set CArgs = ( $CArgs $1 )
                      shift
                   end
                   break
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys net-update -h <do-net-args>"
                   echo ""
                   echo " These are the do-net-args"
                   echo ""
                   echo "    a   - all following args are passed to the script"
                   echo "    b   - do not build (-) or build only (+)"
                   echo "    c   - clean up after aborted attempt"
                   echo "    d   - use distribution file"
                   echo "    e   - use the specified script"
                   echo "    g   - test hosts for availability"
                   echo "    h   - this help message"
                   echo "    i   - do not install (-) or install only (+)"
                   echo "    I   - installs may proceed even with a down host"
                   echo "    m   - do setup in parallel (-) or serial (+) default is -m"
                   echo "    p   - report progress"
                   echo "    q   - don't print tty messages"
                   echo "    s   - do not setup (-) or setup only (+)"
                   echo "    t   - use version, <tag>, for repository update (after -a only)"
                   echo "    v   - verbose mode"
                   exit(1)
                   breaksw
              case -*:
              case +*:
                   set DArgs = ( $DArgs $1 )
                   breaksw
              default:
                   if ("$HostFile" == "") then
                      if (`expr "$1" : '.*:.*'` > 0) then
                         set HostFile = "$1"
                      else if (-e $1) then
                         set HostFile = "$1"
                      else
                         set HostFile = "hosts/$1"
                      endif
                      set DArgs = ( $DArgs $HostFile )
                   else
                      set DArgs = ( $DArgs $1 )
                   endif
                   breaksw
           endsw
           shift
        end

        InitLog Log $LogDir/net-update

        set DO_PACT = $PSY_MngDir/do-pact

        flog $Log $PSY_ScrDir/scs-update
        Note $Log do-net -e $DO_PACT $DArgs $CArgs

#        do-net -e $DO_PACT $DArgs $CArgs |& tee -ai $Log
        fexec $Log do-net -e $DO_PACT $DArgs $CArgs @b tee -ai $Log
        set RStatus = $gstatus[1]

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PACT - set the pact link to the wrapper (smake) or the
#      - portable, persistent (dmake) version

   case pact:
        InitLog Log $LogDir/pact-link
#        set Log = /dev/null

        flog $Log pushd $BinDir
        if ($#argv == 0) then
           set Lst = `ls -l pact`
           echo "   pact linked to $Lst[$#Lst]"
        else
           $RM pact
           if (`expr "$1" : 's.*'` > 0) then
              NoteD $Log "   Linking pact as smake"
              ln -s smake pact
              set RStatus = $status
           else
              NoteD $Log "   Linking pact as dmake"
              ln -s dmake pact
              set RStatus = $status
           endif
        endif
        flog $Log popd

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# REBUILD - attempt to recover and complete a failed NET-UPDATE host/config

   case rebuild:

        set Cfg = ""
        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys rebuild <dev>"
                   echo ""
                   echo "Try to recover from a net-update build failure."
                   echo "This will work best for irreproducible failures"
                   echo "such as NFS errors.  This must be run on the same"
                   echo "kind of machine that the original failed on."
                   echo "   dev  - the configuration to be rebuilt"
                   exit(1)
                   breaksw
              case -*:
              case +*:
                   set DArgs = ( $DArgs $1 )
                   breaksw
              default:
                   set Cfg = $1
                   breaksw
           endsw
           shift
        end

        if ("$Cfg" == "") then
           echo "No config supplied"
           exit(1)
        else if (!(-d $DevDir/$Cfg)) then
           echo "Supplied config, $Cfg, does not exist"
           exit(1)
        else
           echo "Rebuilding $Cfg"
        endif

        InitLog Log $LogDir/rebuild

        flog $Log setenv SESSION_CONFIG $Cfg
        flog $Log source $DevDir/$Cfg/etc/env-pact.csh

        NoteD $Log -n "   Re-compiling ... "
        Note $Log ""
        flog $Log $DSYS build
        set BStat = $status
        if ($BStat != 0) then
           NoteD $Log "failed"
           exit($BStat)
        else
           NoteD $Log "succeeded"
        endif
        
        NoteD $Log -n "   Re-testing ..... "
        Note $Log ""
        flog $Log $DSYS test
        set TStat = $status
        if ($TStat != 0) then
           NoteD $Log "failed"
           exit($TStat)
        else
           NoteD $Log "succeeded"
        endif

        NoteD $Log -n "   Installing ..... "
        Note $Log ""
        flog $Log install-pact
        set IStat = $status
        if ($IStat != 0) then
           NoteD $Log "failed"
           exit($IStat)
        else
           NoteD $Log "succeeded"
        endif

        NoteD $Log -n "   Deleting ....... "
        Note $Log ""
        flog $Log $DSYS delete $Cfg
        set DStat = $status
        if ($DStat != 0) then
           NoteD $Log "failed"
           exit($DStat)
        else
           NoteD $Log "succeeded"
        endif

        set RStatus = 0

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case reconfig:
        set inst = ( -i none )
        set args = "-r"
        set db   = $EtcDir/cfg.db

# get config method and original config file
        if (-f $db) then
           set inf  = ( `pact +l -info RF_CONFIG_METHOD` )
           set meth = $inf[1]
           set cfg  = ( `grep PSY_Cfg= $db |& sed 's/^PSY_Cfg=//'` )
        else
           set meth = file
           set inf  = ( `awk '($1 == "Config") { print $3 }' $EtcDir/configured` )
           set cfg  = $inf[1]:t
        endif
        unset inf

        while ($#argv > 0)
           switch ($1)
              case -c:
                   dsys remove -cfg
                   breaksw
              case -cfg:
                   set meth = file
                   breaksw
              case -db:
                   set meth = database
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys reconfig [-c] [-cfg] [-db] [-i] [-h]"
                   echo ""
                   echo "   c     do remove before config to be completely clean"
                   echo "   cfg   reconfigure from the config file (default)"
                   echo "   db    reconfigure from the database"
                   echo "   i     reconfigure installable (default is non-installable)"
                   echo "   h     this help message"
                   exit(1)
                   breaksw
              case -i:
                   set inst = ""
                   breaksw
              default:
                   set args = ( $args $1 )
                   breaksw
           endsw
           shift
        end

        switch ($meth)
           case database:
                set args = ( $args -db $db )
                breaksw
           case file:
                set args = ( $args $cfg:t )
                unset cfg
                breaksw
        endsw
        unset meth

        $DSYS config $args $inst
        set RStatus = $status

        unset args
        unset inst

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case post:
        echo ""

        if (-x extensions/pact-post) then
           extensions/pact-post $argv
        endif

        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case remove:
        echo ""

        set strict = FALSE
        set Args   = ""

        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   setenv SESSION_CONFIG $1
                   breaksw
              case -cfg:
                   set strict = TRUE
                   breaksw
              case -h:
              case help:
                   echo "Usage: dsys remove [-a <sys>] [-cfg] [-h] [-p #]"
                   echo ""
                   echo "   a     do remove of configuration <sys>"
                   echo "   cfg   do more strict config remove"
                   echo "   h     this help message"
                   echo "   p     do work in parallel"
                   echo ""
                   exit(1)
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
           endsw
           shift
        end

        set DevDir  = $PSY_Base/dev

        setenv PSY_ID     `$PSY_CfgMan -d ../dev use`
        setenv PSY_Root   $DevDir/$PSY_ID
        setenv PSY_TmpDir ${PSY_Prefix}${PSY_ID}

        set BinDir  = $PSY_Root/bin
        set IncDir  = $PSY_Root/include
        set LibDir  = $PSY_Root/lib
        set EtcDir  = $PSY_Root/etc
        set ScmDir  = $PSY_Root/scheme
        set LogDir  = $PSY_Root/log

        InitLog Log $LogDir/remove

        set BeginTime = `$TIMER -r`

        set lpybind = none
        if (-f $EtcDir/cfg.db) then
           set inf = ( `grep PY_DirSrc $EtcDir/cfg.db | sed 's|=| |'` )
           if (("$inf" != "") && ($#inf > 2)) then
              set lpybind = $inf[3]:t
           endif
           unset inf
        endif

# cleanup path so as not to tax wimpy OSs such as Solaris
        eval `$PSY_ScrDir/simplify-path`

        flog $Log date
        flog $Log ( where pact |& head -n 1 )

# do remove for multi-platform configuration
        flog $Log setenv PERDB_PATH $EtcDir/cfg
        dbget PSY_Platforms
        if ("$PSY_Platforms" != "") then
           set Args = ( $Args -f $EtcDir/Makefile )

           set inf = ( `echo "$PSY_Platforms" | sed 's|:| |g'` )
           @ np = $#inf
           Note $Log "$np platforms"

           flog $Log pushd ..
           ftee $Log pact $Args remove
           flog $Log popd
        endif

        NoteD $Log "Removing PACT for $PSY_ID"
        Note $Log "strict = $strict"

# save the files in BinDir
        set BinFiles = ""
        if ($strict == FALSE) then
           set BinFiles = ( $BinFiles smake dmake acc aranlib pact template )
           set BinFiles = ( $BinFiles timer px frnsic )
           set BinFiles = ( $BinFiles do-run elide blang gexec perdb )
           set BinFiles = ( $BinFiles make-syntax )
           set BinFiles = ( $BinFiles import-api pcpp )
           set BinFiles = ( $BinFiles sinstall install-pact install-ext )
        endif
        Note $Log "BinFiles = $BinFiles"

# save the files in IncDir
        set IncFiles = ""
        if ($strict == FALSE) then
           set IncFiles = ( $IncFiles iso-c.h scconfig.h scdecls.h )
           set IncFiles = ( $IncFiles cpyright.h syntax.h )
           set IncFiles = ( $IncFiles posix.h posix-unix.h )
           set IncFiles = ( $IncFiles posix-msw.h posix-beos.h )
           set IncFiles = ( $IncFiles network.h network-unix.h )
           set IncFiles = ( $IncFiles network-msw.h network-beos.h )
           set IncFiles = ( $IncFiles ansic.h )
           set IncFiles = ( $IncFiles f90types.h f90kinds.inc )
        endif
        Note $Log "IncFiles = $IncFiles"

# save the files in EtcDir
        set EtcFiles = ""
        set EtcFiles = ( $EtcFiles configured cfg.conn )
        if ($strict == FALSE) then
           set EtcFiles = ( $EtcFiles do-run-db cfg.db cfg.pco cfg.pl )
           set EtcFiles = ( $EtcFiles cfg.log package )
           set EtcFiles = ( $EtcFiles Makefile make-def make-macros )
           set EtcFiles = ( $EtcFiles env-pact.csh env-pact.sh )
           set EtcFiles = ( $EtcFiles env-pact.dk env-pact.mod )
        endif
        Note $Log "EtcFiles = $EtcFiles"

        set ScmFiles = ""
        if ($strict == FALSE) then
           set ScmFiles = ( $ScmFiles spokes.scm )
        endif
        Note $Log "ScmFiles = $ScmFiles"

# remove scheme files
        NoteD $Log "    in $ScmDir"
        flog $Log pushd $ScmDir
        if ("$ScmFiles" != "") then
           flog $Log mkdir tmp
           flog $Log $MV $ScmFiles tmp
           flog $Log touch foo
           flog $Log $RM $ScmDir/*
           flog $Log $MV tmp/* .
           flog $Log rmdir tmp
        else
           flog $Log $RM $ScmDir/*
        endif
        flog $Log popd

# remove headers
        NoteD $Log "    in $IncDir"
        flog $Log pushd $IncDir
        if ("$IncFiles" != "") then
           flog $Log mkdir tmp
           flog $Log $MV $IncFiles tmp
           flog $Log touch foo
           flog $Log $RM $IncDir/*
           flog $Log $MV tmp/* .
           flog $Log rmdir tmp
        else
           flog $Log $RM $IncDir/*
        endif
        flog $Log popd
 
# remove configs
        NoteD $Log "    in $EtcDir"
        flog $Log pushd $EtcDir
        if ("$EtcFiles" != "") then
           flog $Log mkdir tmp
           flog $Log $MV $EtcFiles tmp
           flog $Log touch foo
           flog $Log $RM $EtcDir/*
           flog $Log $MV tmp/* .
           flog $Log rmdir tmp
        else
           flog $Log $RM $EtcDir/*
        endif
        flog $Log popd
 
# remove binaries
        NoteD $Log "    in $BinDir"
        flog $Log pushd $BinDir
        if ("$BinFiles" != "") then
           flog $Log mkdir tmp
           flog $Log $MV $BinFiles tmp
           flog $Log touch foo
           flog $Log $RM $BinDir/*
           flog $Log $MV tmp/* .
           flog $Log rmdir tmp
        else
           flog $Log $RM $BinDir/*
        endif
        flog $Log popd
 
# remove libraries
        NoteD $Log "    in $LibDir"
        flog $Log pushd $LibDir
        flog $Log touch foo.a foo.so
        flog $Log $RM $LibDir/*.a $LibDir/*.so*
        if (-d $lpybind) then
           flog $Log $RMDir $lpybind
        endif
        flog $Log popd

# remove other files
        NoteD $Log "    in $PSY_Base/"'*'"/$PSY_TmpDir directories"
        flog $Log $RM ../*/$PSY_TmpDir/obj/*.[cfo] ../*/$PSY_TmpDir/obj/*.mod
        flog $Log $RM ../*/*.o ../pdb/spokes/*/*.o ../score/scf77lr.c
        flog $Log $RM ../sx/$PSY_TmpDir/obj/*.[cfo]
        flog $Log $RMDir ../$PSY_TmpDir

        flog $Log pushd ../dev
        flog $Log $RMDir .pc- bin lib include etc log scheme man
        flog $Log popd

# check the result
        flog $Log ls -lR $PSY_Root

        set RStatus = $status

        set ETime = `$TIMER -b $BeginTime`

        NoteD $Log "PACT removed ($RStatus/$ETime)"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# SELECT - select the configuration (for multiple configs per platform)

   case select:

        set Cfg = $1

        echo ""
        echo -n "Changing from configuration `$PSY_CfgMan use` to "

        $PSY_CfgMan add $Cfg
        set RStatus = $status

        echo ""
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case send:
        InitLog Log $LogDir/send

        flog $Log ( where pact |& head -n 1 )

        NoteD $Log ""
        NoteD $Log "Sending PACT Directories ..."
        NoteD $Log ""

        pact -log $Log -cmd $PCKS pact -i send
        set RStatus = $status

        NoteD $Log ""
        NoteD $Log "done"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case shared:
        InitLog Log $LogDir/shared

        flog $Log ( where pact |& head -n 1 )

        set Args = "-i"
        while ($#argv > 0)
           switch ($1)
              case -h :
                   echo ""
                   echo "Usage: dsys shared [-h] [-p #]"
                   echo ""
                   echo "     h  - this help message"
                   echo "     p  - number of nodes to use"
                   echo ""
                   exit(1)
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -* :
                   breaksw
           endsw
           shift
        end

        NoteD $Log ""
        NoteD $Log "Building PACT (with shared libraries)"
        NoteD $Log ""

        flog $Log pushd ..
        pact -log $Log $Args -cmd $PCKS pact shared
        set RStatus = $status

        NoteD $Log ""
        NoteD $Log "done"
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# STATS - plot timing information from update logs

   case stat:
   case stats:

        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   ultra -q -s -l stats.scm \(sh\)
                   exit(1)
                   breaksw

              default:
                   echo ""
                   echo "Unknown option: $1"
                   echo ""
                   exit(1)
                   breaksw
           endsw
           shift
        end

        echo ""
        ultra -q -l stats.scm
        set RStatus = $status
        $RM curves.a

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# STATS-UPDATE - create ultra files with timing information from update logs

   case stats-update:

        set PrntDir   = $PSY_Base:h
        set UpdateDir = $PrntDir/update
        set StatsDir  = $PrntDir/stats

        set DArgs = ""

        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   do-stats -h
                   exit(1)
                   breaksw
              case -s:
                   shift
                   set StatsDir = $1
                   breaksw
              case -u:
                   shift
                   set UpdateDir = $1
                   breaksw
              default:
                   set DArgs = ( $DArgs $1 )
                   breaksw
           endsw
           shift
        end

        do-stats -s $StatsDir -u $UpdateDir $DArgs
        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case sync:

        cd ..

        if ($?USER == 0) then
           if ($?LOGNAME == 0) then
              set USER = "anonymous"
           else
              set USER = $LOGNAME
           endif
        endif

        InitLog Log $LogDir/sync

        set WhoIAm      = $USER
        set Manager     = manager
        set Operation   = "Syncing sources with repository"
        set SCSOpt      = "-q"
        set Quiet       = FALSE

        set ConflFile = $PSY_MngDir/Confl.Sources
        set HelpCode  = $PSY_MngDir/$0
        set Merges    = $PSY_MngDir/merge.el
        set hsy_host  = `uname -n`
        set OS        = `uname -s | tr "[A-Z]" "[a-z]"`

        set SCSRepository = ""
        set SRCDate       = ""
        set Sleep         = "NO"

# define the Source Control System (called twice)
        source ./manager/pact-scs

        set Opt = "$HelpCode:t  $argv"

        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys sync [-h] [-n] [-q] [-s] [-v]"
                   echo ""
                   echo "   h - this help message"
                   echo "   n - do not change any files. Issue report only, do not"
                   echo "       update, or merge any esisting files."
                   echo "   q - quiet mode, just the facts"
                   echo "   s - sleep if lock on"
                   echo "   v - display the Version and Release of the Source Control System"
                   echo ""
                   exit(1)
                   breaksw

              case -n:                                   # NO update, report only
                   set Operation = "Sources differing from repository"
                   set SCSOpt    = ( $SCSOpt -n )
                   breaksw

              case -q:
                   set Quiet = TRUE
                   breaksw

              case -s*:
                   set Sleep = "YES"
                   breaksw

              case -v*:                                  # display version
                   echo "  Source Version:   " $SCSVersion
                   echo "  Software Release: " $SCSRelease
                   echo ""
                   exit(1)

              default:
                   echo ""
                   echo "Unknown option: $1"
                   echo ""
                   exit(1)
                   breaksw
           endsw
           shift
        end

# check if repository locked
        if ($Sleep == "YES") then
           manager/check.lock
        else
           set lockst = `$PSY_ScrDir/scs-lock status`
           if ($lockst == "locked") then
              echo ""
              echo " *** REPOSITORY IS LOCKED ***"
              echo ""
              $PSY_ScrDir/scs-lock cat
              echo ""
              echo ""
              exit(1)
           endif
        endif

# define the Source Control System (repeat to define -n option)
        source ./manager/pact-scs

        if ($Quiet == FALSE) then
           NoteD $Log " "
           NoteD $Log "$Operation (`date`)"
           echo ""
        else
           Note $Log " "
           Note $Log "$Operation (`date`)"
        endif
        Note $Log "  Host: $hsy_host running $OS"
        Note $Log "  User:  $WhoIAm             Date: `date`"
        Note $Log " "  

        Separator $Log
        flog $Log pwd
        flog $Log printenv

# GOTCHA: check git status for things like:
#     Your branch is behind 'origin/master' by <n> commits
# Options:
# 1) quit with complaint
# 2) git stash save ; git pull ; git stash pop
# 3) git stash ; git pull ; git stash clear

        flog $Log $PSY_ScrDir/scs-update
        set xstatus = $status

# take care of conflicting changes
        flog $Log (awk '($1 == "C") && ($2 !~ /Makefile/) {print $2}' $Log > Confl)
        flog $Log set Confl = `cat Confl`
        foreach mod ($Confl)
           NoteD $Log "   C $mod      <-------"
           set xstatus = 10
        end

        cat Confl >&! $ConflFile
        flog $Log $RM Confl

# report changed files
        ftee $Log awk '/^ *[PUMARD] +.*/ {printf("   %s  %s\n", $1, $2);}' $Log @b grep -v manager/.pact-version

        Separator $Log

# if there are no conflicts remove the misleading evidence
        if (-z $ConflFile) then
           flog $Log $RM $ConflFile
        endif

# display list of files in conflict
        if (-e $ConflFile) then
           Note $Log "The following files are in conflict"  
           Note $Log ""                                        
           Note $Log `cat $ConflFile`                          
           Note $Log ""                                        
        endif

        if ($Quiet == FALSE) then
           NoteD $Log ""
           NoteD $Log "(see $Log for detailed information)"
           NoteD $Log ""
        else
           Note $Log ""
           Note $Log "(see $Log for detailed information)"
           Note $Log ""
        endif

        flog $Log cd $Manager

        set RStatus = $xstatus
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case sync-repo:
        InitLog Log $LogDir/sync-repo

        set rsrc = ""
        set rdst = ""
        set excl = ""

        while ($#argv > 0)
           switch ($1)
              case -exclude:
                   shift
                   set excl = ( $excl -exclude $1 )
                   breaksw

              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys sync-repo [-exclude <dir>]* [-h] <src> <dst>"
                   echo ""
                   echo "   exclude  exclude directory dir"
                   echo "   h        this help message"
                   echo "   <src>    source repository"
                   echo "   <dst>    destination repository"
                   echo ""
                   echo "Example:"
                   echo "   dsys sync-repo /here/pact/repo foo:/there/pact/repo"
                   echo ""
                   exit(1)
                   breaksw

              default:
                   if ("$rsrc" == "") then
                      set rsrc = $1
                   else if ("$rdst" == "") then
                      set rdst = $1
                   endif
                   breaksw
           endsw
           shift
        end

        if (("$rsrc" == "") || ("$rdst" == "")) then
           NoteD $Log "Missing repo specification - exiting"
           exit(1)
        endif

        NoteD $Log ""
        NoteD $Log "Updating repository"
        NoteD $Log "   $rdst"
        NoteD $Log "from"
        NoteD $Log "   $rsrc"
        NoteD $Log ""

# prepare the exclusions
        set excl = ( $excl -exclude local )
        set excl = ( $excl -exclude hosts )
        set excl = ( $excl -exclude extensions )
        if (-f $PSY_MngDir/local/exclusions) then
           foreach i (`cat $PSY_MngDir/local/exclusions | grep -v '^#'`)
              set excl = ( $excl -exclude $i )
           end
        endif

        flog $Log set tmp = $cwd/tmp-sync
        flog $Log mkdir $tmp
        flog $Log pushd $tmp

        Separator $Log
        ftee $Log scs-sync $excl $rsrc,tmp $rdst,tmp
        set xstatus = $gstatus[1]

        Separator $Log
        flog $Log cat log.sync
        flog $Log popd
        Separator $Log

        if ($xstatus == 0) then
           NoteD $Log ""
           NoteD $Log "Repository $rdst updated"
           NoteD $Log "see $Log for details"
           flog $Log rm -rf $tmp
        endif
        NoteD $Log ""

        unset tmp

        set RStatus = $xstatus
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case tag:
        pact-commit -t
        set RStatus = $status
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case test:

        set TLog = test
        set Args = "-i"
        set NA   = ( -na 1 )
        set Tgts = ""
        setenv Valgrind  ""
        while ($#argv > 0)
           switch ($1)
              case -a:
                   shift
                   setenv SESSION_CONFIG $1
                   breaksw
              case -dmp :
                   set Args = ( $Args $1 )
                   breaksw
              case -h :
                   echo ""
                   echo "Usage: dsys test [-a <sys>] [-h] [-na #] [-p #] [-r] [-vg] [tgts]*"
                   echo ""
                   echo "     a    do test of configuration <sys>"
                   echo "     h    this help message"
                   echo "     na   number of attempts for each test (default is 1)"
                   echo "     p    number of nodes to use"
                   echo "     r    remove test executables of passing tests"
                   echo "     vg   run most tests under valgrind"
                   echo ""
                   exit(1)
                   breaksw
              case -na :
                   shift
                   set NA = ( -na $1 )
                   breaksw
              case -r :
                   setenv TEST_RM_EXE TRUE
                   breaksw
              case -p :
                   shift
                   if ($1 > 0) then
                      set Args = ( $Args "-async" $1 )
                   endif
                   breaksw
              case -vg :
#                   setenv Valgrind  "valgrind --tool=memcheck --track-origins=yes"
                   setenv Valgrind  "valgrind --tool=memcheck --track-origins=yes --gen-suppressions=all"
                   breaksw
              case -* :
                   breaksw
              default :
                   set Tgts = ( $Tgts $1 )
                   breaksw
           endsw
           shift
        end

        set DevDir = $PSY_Base/dev

        setenv PSY_ID    `$PSY_CfgMan -d ../dev use`
        setenv PSY_Root  $DevDir/$PSY_ID

        set BinDir  = $PSY_Root/bin
        set IncDir  = $PSY_Root/include
        set LibDir  = $PSY_Root/lib
        set EtcDir  = $PSY_Root/etc
        set ScmDir  = $PSY_Root/scheme
        set LogDir  = $PSY_Root/log

        set BeginTime = `$TIMER -r`

# work with mpi-io-wrap to suppress messages from MPI front ends
# that cannot be silenced by their own means
        setenv SC_MPI_SUPPRESS_UNTAGGED

# allow a do-net to activate valgrind testing by doing
# 'var DoValgrind yes' in the host file
        if ($?DoValgrind == 1) then
#           setenv Valgrind  "valgrind --tool=memcheck --track-origins=yes"
           setenv Valgrind  "valgrind --tool=memcheck --track-origins=yes --gen-suppressions=all"
        endif

# verify that valgrind exists before trying to use it
        if ("$Valgrind" != "") then
           set lvg = ( `where valgrind |& head -n 1` )
           if (-x "$lvg") then
              set TLog = test-vg
              InitLog Log $LogDir/$TLog
              Note $Log "Using valgrind: $lvg"
              flog $Log setenv SC_EXEC_N_ATTEMPTS 1
              flog $Log set NA = ( -na 1 )
           else
              setenv Valgrind  ""
              InitLog Log $LogDir/$TLog
              Note $Log "Valgrind requested but not found"
           endif
        else
           InitLog Log $LogDir/$TLog
        endif

# provide context for child processes
        setenv DSYS_TARGET pact_test

        flog $Log ( where pact |& head -n 1 )
        flog $Log umask
        flog $Log setenv SC_EXEC_LOG_FILE ${LogDir}/test.error

# clear out existing test corefiles - easier to investigate any failures
        foreach i (`find .. -name $PSY_TmpDir`)
           flog $Log $RM $i/test/*.core
        end

        set BeginTime = `$TIMER -r`

        NoteD $Log ""
        NoteD $Log "Testing PACT for $PSY_ID ..."
        NoteD $Log " --------------------------------------------------------"

        flog $Log pushd ..

# do it for smake
        flog $Log (ls -l `where pact |& head -n 1` |& grep smake)
        if ($status == 0) then
           set PCKS = ( `awk '$1 == "pkg" {print}' $PSY_MngDir/pact.manifest | sed 's/^pkg//'` )
           foreach d ($PCKS)
              flog $Log pushd $d
              ftee $Log pact $NA test
              if ($gstatus[1] != 0) then
                 set RStatus = 1
              endif
              flog $Log popd
           end

# do it for dmake
        else

# NOTE: this is for the outer pact - the package level one is controlled by NA
           set Args = ( $Args -na 1 )

           if ("$Tgts" == "") then
              ftee $Log pact $Args -f $EtcDir/Makefile test
              set RStatus = $gstatus[1]
           else
              set Tmp  = /tmp/pact-test.$hsy_host.$$
              echo $Tgts >! $Tmp
              flog $Log cat $Tmp
              flog $Log set Tgts = $Tmp

              Note $Log "pact -log $Log $Args -cmd $Tgts pact $NA test"
              pact -log $Log $Args -cmd $Tgts pact $NA test
              set RStatus = $status

              flog $Log $RM $Tmp
              unset Tmp
           endif
        endif

        flog $Log popd

        set ETime = `$TIMER -b $BeginTime`

        NoteD $Log ""
        if ($RStatus == 0) then
           NoteD $Log "All tests passed ($RStatus/$ETime)"
        else

# NOTE: NFS may prevent this from always working
           set Failed = ( `grep 'TEST ... FAILED' $Log |& sed 's/^.*|//' |& awk '{ print $1 }' | tr "[A-Z]" "[a-z]" | sort | uniq` )
           if ("$Failed" == "") then
              flog $Log set RStatus = 0
              NoteD $Log "All tests passed ($RStatus/$ETime)"

           else

# try to find out specific tests that failed
# comparing against tests that passed
              set Passed = ( `grep 'TEST ... PASSED' $Log |& sed 's/^.*|//' |& awk '{ print $1 }' | tr "[A-Z]" "[a-z]" | sort | uniq` )
              set lfail = ""
              foreach f ($Failed)
                 set lok = TRUE
                 foreach p ($Passed)
                    if ($f == $p) then
                       set lok = FALSE
                       break
                    endif
                 end
                 if ($lok == TRUE) then
                    set lfail = ( $lfail $f )
                 endif
              end
              set Failed = ( $lfail )
              unset lfail
              unset lok

# if they all really passed then say so
              if ($#Failed == 0) then
                 flog $Log set RStatus = 0
                 NoteD $Log "All tests passed ($RStatus/$ETime)"

# report failed tests
              else
                 NoteD $Log "$#Failed test(s) failed ($RStatus/$ETime)"
                 NoteD $Log "   $Failed"
              endif
           endif
        endif
        NoteD $Log ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case test-do-net:
        echo ""
        echo "Testing do-net ..."

        foreach i (dnt1 dnt2)
           echo "Starting test $i"
           echo ""
           rm -r test/*
           mkdir -p test/inst

           do-net hosts/$i
           cat test/*.report
        end

        echo "done"
        echo ""

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case test-ssh:
        InitLog Log $LogDir/test-ssh

        echo ""
        echo -n "Testing SSH ..."

        set HFile = hosts/pactnew
        while ($#argv > 0)
           switch ($1)
              case -f:
                   shift
                   set HFile = $1
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo 'Usage: dsys test-ssh [-f <file>] [-h]'
                   echo ""
                   echo "   f      - use file for list of hosts"
                   echo "   h      - this help message"
                   echo ""
                   exit(1)
                   breaksw
           endsw
           shift
        end

        set Tmp = .tmp-dsys-test-ssh.$PSY_ID
        flog $Log $RM $Tmp
        echo "ssh-test" > $Tmp

        set Hosts = `awk '$1 == "host" { print $2 }' $HFile`
        set HFail = ""
        set CFail = ""

        Note $Log "Testing hosts: $Hosts"

        foreach i ($Hosts)
           echo -n '.'

           Separator $Log
           Note $Log "Testing host $i"
           Note $Log ""

# test scp to the host
           Note $Log "Command: pcexec -c 30 scp -v $Tmp ${i}:"
           pcexec -c 30 scp -v $Tmp ${i}: >>& $Log
           set cstat = $status
           if ($cstat != 0) then
              set CFail = ( $CFail $i )
           endif

# test ssh to the host
           Note $Log "Command: pcexec -c 30 ssh -v $i rm -f $Tmp"
           pcexec -c 30 ssh -v $i rm -f $Tmp >>& $Log
           set hstat = $status
           if ($hstat != 0) then
              set HFail = ( $HFail $i )
           endif

        end

        echo " done"

# look for and report failures
        set Rstatus = 0
        if ("$HFail" == "") then
           NoteD $Log "   Your SSH setup is OK"
        else
           NoteD $Log "   Your SSH setup needs work ($HFail)"
           set Rstatus = 1
        endif

        if ("$CFail" == "") then
           NoteD $Log "   Your SCP setup is OK"
        else
           NoteD $Log "   Your SCP setup needs work ($CFail)"
           set Rstatus = 1
        endif

        flog $Log $RM $Tmp
        unset Tmp
        echo " "

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# TICKET - run the ticket suite

   case ticket:
        if ($HaveTicket == TRUE) then
           set Err = 0
           while ($#argv > 0)
              switch ($1)
                 case close:
                      shift
                      if ($#argv > 1) then
                         set Tmp = /tmp/bb.$$
                         echo "$argv[2-]" >! $Tmp
                         $BugTck "close $1 $Tmp"
                         $RM $Tmp
                         unset Tmp
                      else
                         $BugTck "close $1"
                      endif
                      set Err = 0
                      break
                      breaksw
                 case -h:
                 case help:
                      echo ""
                      echo "Usage: dsys ticket [close <ticket> [<msg>]] [give <owner> <ticket>]"
                      echo "                   [list [<user>]] [key <token>] [show <ticket>]"
                      echo "                   [submit <msg>] [summarize [<user>]]"
                      echo ""
                      echo "   close     - close a ticket"
                      echo "   give      - give ticket to owner"
                      echo "   list      - list all tickets or for specified user"
                      echo "   key       - search all tickets for specified keyword"
                      echo "   show      - display a ticket"
                      echo "   submit    - submit a bug report"
                      echo "   summarize - print summaries for your or any single developer's tickets"
                      echo ""
                      set Err = 1
                      break
                      breaksw
                 case give:
                      shift
                      $BugTck "give $1 $2"
                      set Err = 0
                      break
                      breaksw
                 case key:
                      shift
                      $BugTck "cd .. ; grep -i $1 */*"
                      set Err = 0
                      break
                      breaksw
                 case list:
                      shift
                      if ($#argv == 0) then
                         echo "Listing tickets belonging to ${USER}:"
                         $BugTck "ls -CF"
                      else
                         $BugTck "cd .. ; ls -CF $argv"
                      endif
                      set Err = 0
                      break
                      breaksw
                 case show:
                      shift
                      $BugTck "cd .. ; grep -v FB_ */$argv"
                      set Err = 0
                      break
                      breaksw
                 case submit:
                      shift
                      $BugTck "echo $argv | submit"
                      set Err = 0
                      break
                      breaksw
                 case summarize:
                      shift
                      if ($#argv == 0) then
                         echo "Summarizing tickets belonging to ${USER}:"
                         $BugTck "grep 'FB_summary:' * | sed 's/FB_summary://'"
                      else
                         $BugTck "cd ../$argv ; grep 'FB_summary:' * | sed 's/FB_summary://'"
                      endif
                      set Err = 0
                      break
                      breaksw
              endsw
              shift
           end
           echo " "

           set RStatus = $Err
        endif
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case unlock:

        set SCSRepository = ""
        set SRCDate       = ""

        call SCS_SETUP()

        $PSY_ScrDir/scs-lock unlock
        set RStatus = $status
        breaksw        

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case update:

        @ lerr = 0

        set force = FALSE
        set vrb   = FALSE

        set dormv = TRUE
        set dobld = TRUE
        set dotst = TRUE
        set doins = TRUE

        while ($#argv > 0)
           switch ($1)
              case -b:
                   set dobld = FALSE
                   breaksw
              case -force:
                   set force = TRUE
                   breaksw
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys update [-b] [-force] [-h] [-i] [-r] [-t] [-v]"
                   echo "   b     - do not do build step"
                   echo "   force - force install if tests fail"
                   echo "   h     - this help message"
                   echo "   i     - do not do install step"
                   echo "   r     - do not do remove step"
                   echo "   t     - do not do test step"
                   echo "   v     - verbose mode"
                   exit(1)
                   breaksw
              case -i:
                   set doins = FALSE
                   breaksw
              case -r:
                   set dormv = FALSE
                   breaksw
              case -t:
                   set dotst = FALSE
                   breaksw
              case -v:
                   set vrb = TRUE
                   breaksw
           endsw
           shift
        end

        InitLog Log $LogDir/update

        set TIMER = $PSY_Base/scripts/timer
        set BTime = `$TIMER -r`

# remove binaries
        if (($dormv == TRUE) && ($lerr == 0)) then
           set lt = `$TIMER -r`
           NoteD $Log -n "   remove ............ "
           if ($vrb == TRUE) then
              Note $Log ""
              ftee $Log $DSYS remove
              set xstatus = $gstatus[1]
           else
              flog $Log $DSYS remove
              set xstatus = $status
           endif
           set lt = `$TIMER -b $lt`
           if ($xstatus == 0) then
              NoteD $Log "ok ($lt)"
           else
              NoteD $Log "ng ($xstatus/$lt)"
           endif
           @ lerr = $lerr + $xstatus
        endif

# build sources
        if (($dobld == TRUE) && ($lerr == 0)) then
           set lt = `$TIMER -r`
           NoteD $Log -n "   compile ........... "
           if ($vrb == TRUE) then
              Note $Log ""
              ftee $Log $DSYS build
              set xstatus = $gstatus[1]
           else
              flog $Log $DSYS build
              set xstatus = $status
           endif
           set lt = `$TIMER -b $lt`
           if ($xstatus == 0) then
              NoteD $Log "ok ($lt)"
           else
              NoteD $Log "ng ($xstatus/$lt)"
           endif
           @ lerr = $lerr + $xstatus
        endif

# run test suite
        if (($dotst == TRUE) && ($lerr == 0)) then
           set lt = `$TIMER -r`
           NoteD $Log -n "   test .............. "
           if ($vrb == TRUE) then
              Note $Log ""
              ftee $Log $DSYS test
              set xstatus = $gstatus[1]
           else
              flog $Log $DSYS test
              set xstatus = $status
           endif
           set lt = `$TIMER -b $lt`
           if ($xstatus == 0) then
              NoteD $Log "ok ($lt)"
           else
              if ($force == TRUE) then
                 set xstatus = 0
                 NoteD $Log "passed ($xstatus/$lt)"
              else
                 NoteD $Log "ng ($xstatus/$lt)"
              endif
           endif
           @ lerr = $lerr + $xstatus
        endif

# install
        if (($doins == TRUE) && ($lerr == 0)) then
           set lt = `$TIMER -r`
           NoteD $Log -n "   install ........... "
           if ($vrb == TRUE) then
              Note $Log ""
              ftee $Log $BinDir/install-pact
              set xstatus = $gstatus[1]
           else
              flog $Log $BinDir/install-pact
              set xstatus = $status
           endif
           set lt = `$TIMER -b $lt`
           if ($xstatus == 0) then
              NoteD $Log "ok ($lt)"
           else
              NoteD $Log "ng ($xstatus/$lt)"
           endif
           @ lerr = $lerr + $xstatus
        endif

        set ETime = `$TIMER -b $BTime`

        NoteD $Log ""
        set RStatus = $lerr
        if ($RStatus == 0) then
           Note $Log "PACT Update succeeded ($RStatus/$ETime)"
        else
           Note $Log "PACT Update failed ($ETime)"
        endif

        unset xstatus
        unset lerr

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# UPDATE-SYS - update pact everywhere using update-sys

   case update-sys:

        shift

        set Opt  = ""
        set Tag  = ""
        set Site = "-a"
        while ($#argv > 0)
           switch ($1)
              case -h:
              case help:
                   echo ""
                   echo "Usage: dsys update-sys [-h] [-s <site>] -l | new | exp | <vers>"
                   echo ""
                   echo "   h   this help message"
                   echo "   l   list any existing tags"
                   echo "   s   update only <site>"
                   echo ""
                   echo "Example:"
                   echo "   dsys update-sys -l      list tags"
                   echo "   dsys update-sys std     update pact at all sites"
                   echo "   dsys update-sys new     update pactnew at all sites"
                   echo ""
                   exit(1)
                   breaksw
              case -s:
                   shift
                   set Site = ( -s $1 )
                   breaksw
              case -*:
                   set Opt = ( $Opt $1 )
                   breaksw
              default:
                   switch ($1)
                      case new:
                      default:
                           set Tag = pact.new
                           breaksw
                      case std:
                           set Tag = pact.std
                           breaksw
                   endsw
                   breaksw
           endsw
           shift
        end

        set Log = $DevLog/update-sys
        $RM $Log
        touch $Log

        set Cmd = "update-sys $Opt $Site $Tag"

        Note $Log "Command: $Cmd"

#        $Cmd |& tee -ai $Log
        fexec $Log $Cmd @b tee -ai $Log
        set RStatus = $gstatus[1]

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   default:
       echo "Unknown option: $Cmnd"

endsw

exit($RStatus)

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# GEN_CONFIG - generate configuration from command line arguments alone
#            - e.g.   -t -py

GEN_CONFIG:

   if (($pthread == TRUE) && ($openmp == TRUE)) then
      echo "pthread and openmp are mutually exclusive options - pick one"
      exit(1)
   endif

   set vrb = FALSE

   set gdir = gen/$PSY_Arch
   if (!(-d $gdir)) then
      mkdir -p $gdir
   endif

   set Tmp = $gdir/tmp.$$

   source write/cfg-base
   source write/cfg-features
 
   mv $Tmp $gdir/$cfg
   set Configuration = $cfg

   unset Tmp

   return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

SCS_SETUP:

   source $PSY_MngDir/pact-scs

   return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
