#!/usr/bin/env sx
;
; DRUN - run multiple instances of commands differentially
;

(define jobs nil)
(define vrb  #f)

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-GET-INDEX - return the 1 based index for JOB

(define (job-get-index jb)
    (if (pair? jb)
	(list-ref jb 0)
	-1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-GET-PROCESS - return the process for JOB

(define (job-get-process jb)
    (if (pair? jb)
	(list-ref jb 1)
	nil))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-GET-OUT-BUFFER - return the output buffer for JOB

(define (job-get-out-buffer jb)
    (if (pair? jb)
	(list-ref jb 2)
	nil))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-NUMBER - return the 1 based job index of JOB

(define (job-number-aux job jlst n)
    (if (pair? jlst)
	(let* ((jb (list-ref jlst 0)))
	      (if (eqv? job (job-get-process jb))
		  (job-get-index jb)
		  (job-number-aux job (list-tail jlst 1) (+ n 1))))
	n))

(define (job-number job)
    (job-number-aux job jobs 1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-WHICH - return the process JB containing JOB

(define (job-which-aux job jlst)
    (if (pair? jlst)
	(let* ((jb (list-ref jlst 0)))
	      (if (eqv? job (job-get-process jb))
		  jb
		  (job-which-aux job (list-tail jlst 1))))))

(define (job-which job)
    (job-which-aux job jobs))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-PUSH-RESPONSE - push output from job JB
;                   - in response to a job-send-cmd

(define (job-push-response jb)
    (let* ((job (job-get-process jb))
           (bf  (job-get-out-buffer jb))
	   (s   (process-read-line job)))
          (if s
	      (begin (set-car! (cddr jb) (string-append bf s))
		     (job-push-response jb))
	      (job-pop-line jb))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-POP-LINE - pop complete line of text from job JB

(define (job-pop-line jb)
    (let* ((bf (job-get-out-buffer jb))
	   (t  (if (null? bf) "" bf))
	   (s  (strtok t "\n"))
	   (r  (strtok t "")))
          (set-car! (cddr jb) r)
          (if s
	      (let* ((n (job-get-index jb)))
		    (printf nil "%d | %s\n" n s)
		    (job-pop-line jb))
	      (if r
		  (job-pop-line jb)))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-SEND-CMD - send text CMD to job JB

(define (job-send-cmd jb cmd)
    (let* ((jn  (job-get-index jb))
	   (job (job-get-process jb)))
          (if vrb
	      (printf nil "sending to %d> %s\n" jn cmd))
          (process-send-line job cmd)
	  (job-push-response jb)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-SHOW-STATUS - show the status of process JOB

(define (job-show-status job)
    (let* ((stat (process-status job))
	   (runs (cdddr stat))
	   (runp (car runs))
	   (reason (cadr runs)))
          (printf nil
		  "Status for process \#%d: %s\n"
		  (car stat)
		  (cond ((= runp 0)  "Running")
			((= runp 1)  (sprintf "Stopped (%d)" reason))
			((= runp 2)  (sprintf "Changed (%d)" reason))
			((or (= runp 4) (= runp 6))
			 (sprintf "Exited (%d)" reason))
			((or (= runp 8) (= runp 10))
			 (sprintf "Coredumped (%d)" reason))
			((= runp 16) (sprintf "Signaled (%d)" reason))
			(else        (sprintf "Unkown (%d %d)" runp reason))))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-EXIT-STATUS - wait for process JOB of job JN to exit
;                 - and return the reason

(define (job-exit-status jb)
    (let* ((jn  (job-get-index jb))
	   (job (job-get-process jb)))
          (sleep 500)
	  (job-push-response jb)
	  (let* ((stat (process-status job))
		 (runs (cdddr stat))
		 (runp (car runs))
		 (reason (cadr runs)))
	        (if (= runp 0)
		    (job-exit-status jb)
		    reason))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; POLL-READ - read method for poll on processes

(define (poll-read job)
    (let* ((jb (job-which job))
	   (st (change-term-state nil TERM_COOKED FALSE)))
          (job-push-response jb)
	  (change-term-state nil st FALSE)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; POLL-WRITE - write method for poll on processes
;            - not currently used

(define (poll-write job)
    (printf nil "> poll write %s\n" job))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; MAKE-JOB - exec a new job
;          - this means spawning a new process,
;          - writing the function to send it messages,
;          - and adding it to the list of jobs

(define (make-job fmt . x)
    (let* ((cmd (apply sprintf (cons fmt x)))
           (job (process-open "a" (list cmd) poll-read poll-write))
	   (jn  (job-number nil))
	   (jnm (string->symbol (sprintf "p%d" jn)))
	   (jb  (list jn job ""))

  	   (msn (eval `(define-global-macro ,(list jnm 'msg)
			   (job-send-cmd (quote ,jb)
					     (sprintf "\"%s\"" msg))))))

; check that the jobs is running and get startup messages
;          (job-show-status job)
	  (sleep 100)
	  (job-push-response jb)

; add the job to the list
          (set! jobs (reverse (cons jb (reverse jobs))))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; DONE - cleanup and exit this session

(define (done)
    (let* ((st 0))

          (define (do-one x)
	      (let* ((jn  (job-get-index x))
		     (job (job-get-process x))
		     (js  (job-exit-status x)))
		    (if (not (= js 0))
			(set! st js))
		    (process-close job)))

          (for-each do-one jobs)

	  (quit st)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; PA - send command CMD to all jobs

(define-macro (pa cmd)

    (define (do-one x)
        (job-send-cmd x (sprintf "%s" cmd)))

    (for-each do-one jobs))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; HELP - print help message

(define (help)
   (printf nil "\n")
   (printf nil "Usage: drun [--help] [--vrb] <cmd>*\n")
   (printf nil "   help  this help message\n")
   (printf nil "   vrb   run more verbosely\n")
   (printf nil "   <cmd> job command line\n")
   (printf nil "\n")
   (quit 1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; MAIN - start here - mostly

(define (main args jl)
   (let* ((arg (list-ref args 0))
	  (rst (list-tail args 1)))
         (cond ((null? arg)
		(if jl
		    (c-repl "drun> " " ")
		    (help)))
	       ((string=? arg "--help")
		(help))
	       ((string=? arg "--vrb")
		(set! vrb #t))
	       (else
		(main rst (make-job arg))))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

(enter-pdbview-mode)
(main argv)

