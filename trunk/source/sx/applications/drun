#!/usr/bin/env pdbview
;
; DRUN - run multiple instances of commands differentially
;

(define jobs nil)
(define vrb  #f)

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-GET-INDEX - return the 1 based index for JOB

(define (job-get-index jb)
    (list-ref jb 0))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-GET-PROCESS - return the process for JOB

(define (job-get-process jb)
    (list-ref jb 1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-NUMBER - return the 1 based job index of JOB

(define (job-number-aux job jlst n)
    (if (pair? jlst)
	(let* ((jb (list-ref jlst 0)))
	      (if (eqv? job (job-get-process jb))
		  (job-get-index jb)
		  (job-number-aux job (list-tail jlst 1) (+ n 1))))
	n))

(define (job-number job)
    (job-number-aux job jobs 1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-DISPLAY-RESPONSE - display output from JOB N
;                      - in response to a job-send-command

(define (job-display-response job n)
    (let* ((s  (process-read-line job))
	   (lc (char->integer (list-ref (string->list (substring s -1 1))
					0))))
          (if s
	      (begin (if (= lc 10)
			 (printf nil "%d | %s" n s)
;			 (printf nil "%d %s | %s" n job s)
			 (printf nil "%s" s))
		     (job-display-response job n))
	      (printf nil "\n"))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-SEND-COMMAND - send text CMD to job JB

(define (job-send-command jb cmd)
    (let* ((jn  (job-get-index jb))
	   (job (job-get-process jb)))
          (process-send-line job cmd)
	  (job-display-response job jn)
;	  (job-show-status job)
	  ))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-SHOW-STATUS - show the status of process JOB

(define (job-show-status job)
    (let* ((stat (process-status job))
	   (runs (cdddr stat))
	   (runp (car runs))
	   (reason (cadr runs)))
          (printf nil
		  "Status for process \#%d: %s\n"
		  (car stat)
		  (cond ((= runp 0)  "Running")
			((= runp 1)  (sprintf "Stopped (%d)" reason))
			((= runp 2)  (sprintf "Changed (%d)" reason))
			((or (= runp 4) (= runp 6))
			 (sprintf "Exited (%d)" reason))
			((or (= runp 8) (= runp 10))
			 (sprintf "Coredumped (%d)" reason))
			((= runp 16) (sprintf "Signaled (%d)" reason))
			(else        (sprintf "Unkown (%d %d)" runp reason))))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; JOB-EXIT-STATUS - wait for process JOB of job JN to exit
;                 - and return the reason

(define (job-exit-status job jn)
    (sleep 500)
    (job-display-response job jn)
    (let* ((stat (process-status job))
	   (runs (cdddr stat))
	   (runp (car runs))
	   (reason (cadr runs)))
          (if (= runp 0)
	      (job-exit-status job)
	      reason)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

(define (poll-read job)
(printf nil "\npoll-read> %d %s ----------------------\n"
	(job-number job) job)
    (let* ((n (job-number job)))
          (job-display-response job n)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

(define (poll-write job)
    (printf nil "> poll read %s\n" job))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; MAKE-JOB - exec a new job
;          - this means spawning a new process,
;          - writing the function to send it messages,
;          - and adding it to the list of jobs

(define (make-job fmt . x)
    (let* ((cmd (apply sprintf (cons fmt x)))
           (job (process-open "a" (list cmd) poll-read nil))
	   (jn  (job-number nil))
	   (jnm (string->symbol (sprintf "p%d" jn)))
	   (jb  (list jn job))

  	   (msn (eval `(define-global-macro ,(list jnm 'msg)
			   (job-send-command (quote ,jb)
					     (sprintf "\"%s\"" msg))))))

; check that the jobs is running and get startup messages
;          (job-show-status job)
	  (sleep 100)
	  (job-display-response job jn)

; add the job to the list
          (set! jobs (cons jb jobs))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; DONE - cleanup and exit this session

(define (done)
    (let* ((st 0))

          (define (do-one x)
	      (let* ((jn  (job-get-index x))
		     (job (job-get-process x))
		     (js  (job-exit-status job)))
		    (if (not (= js 0))
			(set! st js))
		    (process-close job)))

          (for-each do-one jobs)

	  (quit st)))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; PA - send command CMD to all jobs

(define-macro (pa cmd)

    (define (do-one x)
        (job-send-command x (sprintf "%s" cmd)))

    (for-each do-one jobs))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; HELP - print help message

(define (help)
   (printf nil "\n")
   (printf nil "Usage: drun [--help] [--vrb] <cmd>*\n")
   (printf nil "   help  this help message\n")
   (printf nil "   vrb   run more verbosely\n")
   (printf nil "   <cmd> job command line\n")
   (printf nil "\n")
   (quit 1))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

; MAIN - start here - mostly

(define (main args jl)
   (let* ((arg (list-ref args 0))
	  (rst (list-tail args 1)))
         (cond ((null? arg)
		(if jl
		    (c-repl "drun> " " ")
		    (help)))
	       ((string=? arg "--help")
		(help))
	       ((string=? arg "--vrb")
		(set! vrb #t))
	       (else
		(main rst (make-job arg))))))

;--------------------------------------------------------------------------
;--------------------------------------------------------------------------

(enter-pdbview-mode)
(main argv)

