#!/bin/csh -f
#
# LBIND - generate wrappers of C functions for SCHEME and Fortran
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

unalias *

set Err   = 0
set Arch  = `cfgman use`
set ZArch = z-$Arch
set Which = "$cwd/pwhich"

source ../dev/$Arch/include/env-pact.csh
source ../dev/$Arch/include/env-csh

SafeEnv CROSS_COMPILE FALSE

if ($CROSS_COMPILE == FALSE) then
   set CFE = ""
else
   set CFE = "do-run"
endif

InitLog Log $cwd:h/dev/$Arch/log/lbind

set FC      = `pact +l -info FCompiler`
set BaseDir = $cwd:h/dev/$Arch
set IncDir  = $BaseDir/include
set LibDir  = $BaseDir/lib
set SzAddr  = `$CFE detect | grep "A pointer is"`
set SzAddr  = $SzAddr[4]

if ("$FC" == "") then
   NoteD $Log "   No Fortran compiler specified - exiting"
   exit(1)
endif

set FCExe = `$Which $FC`
if (!(-x "$FCExe")) then
   NoteD $Log "   Fortran compiler $FC not found - exiting"
   exit(2)
endif

set FCFlags = `pact +l -info FFLAGS`
set AR      = `pact +l -info AR`
set AROpt   = `pact +l -info AROpt`

Note $Log ""
NoteD $Log "   Generating F90 interfaces using:"
Note $Log "      Compiler:  $FCExe"
Note $Log "      Includes:  $IncDir"
Note $Log "      Addr size: $SzAddr"
Note $Log "      AR:        $AR"
Note $Log "      AROpt:     $AROpt"
Note $Log ""

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# GENERATE - generate interfaces for each package

flog $Log set Dirs = ( score pml pdb ppc pgs panacea scheme sx ultra )
foreach d ($Dirs)

   Separator $Log
   flog $Log pushd ../$d

   @ CCount = `echo $d | wc -c`
   @ NDots  = 20 - $CCount
   set Fill = "$d "
   while ($NDots > 0)
      set Fill = "$Fill."
      @ NDots = $NDots - 1
   end

   NoteD $Log -n "      $Fill "
   Note $Log ""

   flog $Log set pck = $ZArch/$d

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PARSE - parse the pre-Make file and make a file list

   set Lst = ( `grep '${TGTLib}(' pre-Make | sed 's/TGTLib//g' | sed 's/[=()$\]//g'` )
   set Files = ""
   foreach i ($Lst)
      set j = $i:r.c
      if (-f $j) then
         set Files = ( $Files $j )
      endif
   end

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# TRANSFORM - process the C declarations
#           - the transformations are:
#   elide '/*' '*/' $Files                         remove C comments
#   elide '{' '}' -                                remove compound statements
#   sed 'N;s/\\\n//'                               combine lines ending in \
#   elide '#if' '#endif' -                         remove conditionals
#   grep -v '#'                                    remove #include, #define
#   sed 's/[ \t][ \t]*/ /g'                        compress whitespace
#   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }    
#        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }' combine lines ending in ,
#   sed '/^[ \t]*$/d'                              remove blank lines
#   sed '/;[ \t]*$/d'                              remove lines ending in ;
#   grep -v '='                                    remove lines with assignments
#

   elide '/*' '*/' $Files                          | \
   elide '{' '}' -                                 | \
   sed 'N;s/\\\n//'                                | \
   elide '#if' '#endif' -                          | \
   grep -v '#'                                     | \
   sed 's/[ \t][ \t]*/ /g'                         | \
   awk '$0 ~ /,[ \t]*$/   { printf("%s", $0) }       \
        $0 !~ /,[ \t]*$/  { printf("%s\n", $0) }'  | \
   sed '/^[ \t]*$/d'                               | \
   sed '/;[ \t]*$/d'                               | \
   grep -v '='                                     | \
   grep -v 'FIXNUM'                                | \
   grep -v 'static'                                | \
   grep '('                                        | \
   sort                                            | \
   cat >&! $pck.proto

# Fortran binding

# Scheme binding

# Python binding

# Document

echo "Result:"
echo "blang $pck.proto ../$d/$d.bind"
pwd
#cat $pck.proto
exit(1)

   flog $Log rm -f $pck.proto

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# place generated bindings source

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   if ($xstatus == 0) then
      NoteD $Log "ok"
   else
      NoteD $Log "ng"
   endif
   flog $Log popd
end

exit($Err)

