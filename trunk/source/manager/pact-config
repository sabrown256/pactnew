#!/bin/csh -f
#
# PACT-CONFIG - processor for auto-configuration information
#             - this script is like the PCO program but lacks the RUN command
#
# Source Version: 3.0
# Software Release #: LLNL-CODE-422942
#
# include "cpyright.h"
#

unalias *

if ($?sys_mngdir == 0) then
   if ($?USER == 0) then
      if ($?LOGNAME == 0) then
         set USER = "anonymous"
      else
         set USER = $LOGNAME
      endif
   endif

   set sys_mngdir = $cwd
   set sys_base   = $sys_mngdir:h

   setenv SYS_Base   $sys_base
   setenv SYS_ScrDir $SYS_Base/scripts

   source $SYS_ScrDir/functions-pact.csh
endif

source $SYS_ScrDir/csh-subroutines
HAVE_SUBROUTINES

if ($#argv < 1) then
   echo ""
   echo "Usage: pact-config [-a] [-c] [-F] [-g] [-i <directory>] [-s <sysid>] [-t] [-v] -n | <site>"
   echo ""
   echo "             -a      do NOT perform PACT-ANALYZE step"
   echo "             -c      create missing directories for -i option"
   echo "             -F      do builds in /tmp for speed"
   echo "             -g      build debuggable no matter what"
   echo "             -i      base installation directory (default /usr/local)"
   echo "             -n      do an auto-configuration"
   echo "             -p      emit files with defaults (no <file> required)"
   echo "             -s      explicit system id"
   echo "             -t      trace on (diagnostic)"
   echo "             -v      verbose on (diagnostic)"
   echo "             <site>  the configuration for the installation"
   echo "                     config file must be of the form [<path>/]<site>.config"
   echo ""
   exit(1)
endif

set noglob

alias RESET_VAR  'setenv \!\!:1_\!\!:2 \!\!:3-$'
alias DEFD_VAR   'set ok = `env | grep \!\!:1`'
alias VAR_VAL_SP 'set value = `printenv \!\!:1_\!\!:2 | sed "s^ ^+sp+^g"`'
alias VAR_VALUE  'set value = `printenv \!\!:1_\!\!:2`'

set DoingConfig = TRUE
set DefTools    = ""
set DefGroups   = "Glb"
set StructStack = "Glb"
setenv CurrTool  ""
setenv CurrGrp   Glb

set path = ( $sys_mngdir $path )

# Source Control System Variables
set SCSRepository = ""
set SRCDate       = ""

source pact-scs

setenv SYS_Host    `uname -n`
setenv OS_Name     `uname -s`
setenv OS_Release  `uname -r`

setenv SYS_Arch `$SYS_ScrDir/system-id`

#
# Global Variables
#
@ nrun = 0

set Verbose         = FALSE
set Templates       = FALSE
set CONFIG_FILE     = DEFAULT
set NoConfig        = FALSE
set NoAnalyze       = FALSE

set IBSet        = dflt
set CreateDirs   = FALSE

setenv UseTmpDir      FALSE
setenv AbsoluteDeb    FALSE
setenv AbsoluteOpt    FALSE
setenv CROSS_COMPILE  FALSE

setenv SYS_CfgMan  $SYS_ScrDir/cfgman
setenv SYS_ID      `$SYS_CfgMan use`
setenv SYS_CfgDir  cfg-$SYS_ID
setenv SYS_MngDir  $cwd

setenv SYS_Root $SYS_Base/dev/$SYS_ID
setenv IncDir   $SYS_Root/include
setenv EtcDir   $SYS_Root/etc
setenv BinDir   $SYS_Root/bin
setenv LibDir   $SYS_Root/lib
setenv ScmDir   scheme
setenv Man1Dir  man/man1
setenv Man3Dir  man/man3
setenv EnvCsh   $EtcDir/env-pact.csh
setenv EnvSh    $EtcDir/env-pact.sh
setenv EnvDk    $EtcDir/env-pact.dk


setenv CEFile   $SYS_Root/log/file.ce
setenv CDFile   $SYS_Root/log/file.cd
setenv DPFile   $SYS_Root/log/file.dpe
setenv SEFile   $SYS_Root/log/file.se
setenv MVFile   $SYS_Root/log/file.mv
setenv URFile   $SYS_Root/log/file.ur
setenv Log      $SYS_Root/log/config

setenv NoExe   FALSE
setenv Load    TRUE

setenv PFE     "$BinDir/do-run -m"
setenv CFE

flog $Log (env | sort)

# define the set of specifications which define a tool
set lToolSpec = ""
set lToolSpec = ( $lToolSpec Exe Flags Version Debug Optimize Shared )
set lToolSpec = ( $lToolSpec Inc Lib )
set lToolSpec = ( $lToolSpec IFlag XFlag )

# define and initialize the (special) config variables
set lConfigVars = ""
set lConfigVars = ( $lConfigVars CC_Exe CC_Linker CC_Flags CC_Debug CC_Optimize )
set lConfigVars = ( $lConfigVars CC_Inc )
set lConfigVars = ( $lConfigVars FC_Exe FC_Linker FC_Flags FC_Debug FC_Optimize )
set lConfigVars = ( $lConfigVars LD_Exe LD_Flags LD_Lib )

# variable defaults

setenv SYS_InstRoot   none
setenv FPU            unknown
setenv Globals        ""

setenv PubInc  "-I$SYS_InstRoot/include"
setenv PubLib  "-L$SYS_InstRoot/lib"

# we need the back slash treatment now - later will not do
source analyze/backslash

$RMDir $SYS_CfgDir
mkdir $SYS_CfgDir

flog $Log date

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# MAIN - start it out here

Main:

    while ($#argv > 0)
       switch ($1)
          case -a:
                   set NoAnalyze = TRUE
                   breaksw

          case -c:
                   set CreateDirs = TRUE
                   breaksw

          case -F:
                   setenv UseTmpDir FALSE
                   breaksw

          case +F:
                   setenv UseTmpDir TRUE
                   breaksw

          case -g:
                   setenv AbsoluteDeb TRUE
                   breaksw

          case -i:
                   shift
                   setenv SYS_InstRoot $1
                   if ("$SYS_InstRoot" =~ */) then
                      setenv SYS_InstRoot `expr "$SYS_InstRoot" : '\(.*\)/'`
                   endif
                   setenv PubInc "-I$SYS_InstRoot/include"
                   setenv PubLib "-L$SYS_InstRoot/lib"
                   set IBSet = "input"
                   breaksw

          case -n:
                   set NoConfig = TRUE
                   breaksw

          case -o:
                   setenv AbsoluteOpt TRUE
                   breaksw

          case -p:
                   set Templates = TRUE
                   breaksw

          case -s:
                   shift
                   setenv SYS_ID   $1
                   setenv SYS_Root  $SYS_Base/dev/$SYS_ID
                   setenv IncDir   $SYS_Root/include
                   setenv EnvCsh   $EtcDir/env-pact.csh
                   setenv EnvSh    $EtcDir/env-pact.sh
                   setenv EnvDk    $EtcDir/env-pact.dk
                   breaksw

          case -t:
                   set Trace = TRUE
                   breaksw

          case -v:
                   set Verbose = TRUE
                   breaksw
          default:
                   set CONFIG_FILE = $1
                   breaksw
       endsw
       shift
    end

    set lcfg = $CONFIG_FILE:t
    setenv SYS_Cfg  $lcfg
    unset lcfg

    flog $Log $RM $CEFile
    flog $Log touch $CEFile
    flog $Log $RM $CDFile
    flog $Log touch $CDFile
    flog $Log $RM $SEFile
    flog $Log touch $SEFile
    flog $Log $RM $MVFile
    flog $Log touch $MVFile
    flog $Log $RM $URFile
    flog $Log touch $URFile

    set STDOUT = "$URFile"

    echo ""

# Setup the rules for CC, Lex, Yacc, and FC
    if ($Verbose == "TRUE") then
      set CCP     = ( '\t${CC} -P $<\n' )
      set CCObj   = ( '\t${CC} -c $< -o $@\n' )
      set CCArc   = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${CC} -c ${PACTSrcDir}/$< -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2> /dev/null ; '$BackSlash'\n          ${RM} $*.o 2> /dev/null )\n' )
      
      set LexObj  = ( '\t${LEX} $< 2> /dev/null\n\tsed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c\n\t(echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1\n\t${LX} -c $*.c\n\trm lex.yy.c $*.c\n' )
      set LexArc  = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${LEX} -t ${PACTSrcDir}/$< 1> lex.yy.c 2> /dev/null ; '$BackSlash'\n          sed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1 ; '$BackSlash'\n          echo "${LX} -c $*.c" ; '$BackSlash'\n          ${LX} -c $*.c -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2> /dev/null ; '$BackSlash'\n          ${RM} lex.yy.c $*.c )\n' )
      set LexC    = ( '\t@(cd ${PACTTmpDir} ; '$BackSlash'\n         ${LEX} ${PACTSrcDir}/$< 2> /dev/null ; '$BackSlash'\n\t@sed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c ; '$BackSlash'\n\t@(echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1 ; '$BackSlash'\n\t@${RM} lex.yy.c)\n' )
      set YaccObj = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2> /dev/null ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1 ; '$BackSlash'\n          ${YC} -c $*.c -o $*.o ; '$BackSlash'\n          ${RM} $*.c )\n' )
      set YaccArc = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2> /dev/null ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1 ; '$BackSlash'\n          echo "${YC} -c $*.c" ; '$BackSlash'\n          ${YC} -c $*.c -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2> /dev/null ; '$BackSlash'\n          ${RM} $*.c $*.o )\n' )
      set YaccC   = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2> /dev/null ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed > /dev/null 2>&1 ; '$BackSlash'\n          mv $*.c ${PACTSrcDir} )\n' )
      
      set FCObj   = ( '\t${FC} -c $< -o $@\n' )
      set FCArc   = ( '\t(cd ${PACTTmpDir} ; '$BackSlash'\n          ${FC} -c ${PACTSrcDir}/$< -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2> /dev/null ; '$BackSlash'\n          ${RM} $*.o 2> /dev/null )\n' )

    else

      set CCP     = ( '\t@(echo "${CCAnnounce} -P $<" ; '$BackSlash'\n          ${CC} -P $<)\n' )
      set CCObj   = ( '\t@(echo "${CCAnnounce} -c $<" ; '$BackSlash'\n          ${CC} -c $< -o $@)\n' )
      set CCArc   = ( '\t@(echo "${CCAnnounce} -c $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${CC} -c ${PACTSrcDir}/$< -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2>> errlog ; '$BackSlash'\n          ${RM} $*.o 2>> errlog)\n' )
      
      set LexObj  = ( '\t@(echo "lex $<" ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${LEX} $< 2>> errlog ; '$BackSlash'\n          sed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          ${LX} -c $*.c ; '$BackSlash'\n          ${RM} lex.yy.c $*.c)\n' )
      set LexArc  = ( '\t@(echo "lex $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${LEX} -t ${PACTSrcDir}/$< 1> lex.yy.c 2>> errlog ; '$BackSlash'\n          sed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          echo "${LX} -c $*.c" ; '$BackSlash'\n          ${LX} -c $*.c -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2>> errlog ; '$BackSlash'\n          ${RM} lex.yy.c $*.c)\n' )
      set LexC    = ( '\t@(echo "lex $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${LEX} ${PACTSrcDir}/$< 2>> errlog ; '$BackSlash'\n          sed "s|lex.yy.c|$*.c|" lex.yy.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          ${RM} lex.yy.c)\n' )

      set YaccObj = ( '\t@(echo "yacc $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2>> errlog ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          ${YC} -c $*.c -o $*.o ; '$BackSlash'\n          ${RM} $*.c)\n' )
      set YaccArc = ( '\t@(echo "yacc $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2>> errlog ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          echo "${YC} -c $*.c" ; '$BackSlash'\n          ${YC} -c $*.c -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2>> errlog ; '$BackSlash'\n          ${RM} $*.c $*.o)\n' )
      set YaccC   = ( '\t@(echo "yacc $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${YACC} ${PACTSrcDir}/$< 2>> errlog ; '$BackSlash'\n          sed "s|y.tab.c|$*.c|" y.tab.c > $*.c ; '$BackSlash'\n          (echo '"'"'e $*.c'"'"' ; echo '"'"'1,$$s/yy/$*_/g'"'"' ; echo '"'"'1,$$w $*.c'"'"' ; echo '"'"'q'"'"' ) | ed >> errlog 2>&1 ; '$BackSlash'\n          mv $*.c ${PACTSrcDir})\n' )
      
      set FCObj   = ( '\t@(echo "${FCAnnounce} -c $<" ; '$BackSlash'\n          ${FC} -c $< -o $@)\n' )
      set FCArc   = ( '\t@(echo "${FCAnnounce} -c $<" ; '$BackSlash'\n          cd ${PACTTmpDir} ; '$BackSlash'\n          ${RM} errlog ; '$BackSlash'\n          touch errlog ; '$BackSlash'\n          ${FC} -c ${PACTSrcDir}/$< -o $*.o ; '$BackSlash'\n          ${AR} ${AROpt} ${TGTLib} $*.o 2>> errlog ; '$BackSlash'\n          ${RM} $*.o 2>> errlog )\n' )
    endif

    if ($Templates == FALSE) then

       if ($NoConfig == FALSE) then
          if (-f analyze/program-init) then
             call ReadConfig(analyze/program-init TRUE)
          endif
          call ReadConfig($CONFIG_FILE)
       endif

       call CheckDir()

       if ($NoAnalyze == FALSE) then
          call AnalyzeConfig()
       endif

       call SummarizeConfig()

    endif

    call Finish()

    exit(0)

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# ANALYZECONFIG - analyze the system configuration

AnalyzeConfig:

    NoteD $Log ""
    NoteD $Log "Analyzing system on $SYS_Host"

    write/envf FALSE
    
    flog $Log pushd $SYS_CfgDir

    include $SYS_MngDir/pact-analyze

# restore config as the log file
    set Log = "$SYS_Root/log/config"
    flog $Log $RM `ls`
    flog $Log popd

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# SUMMARIZECONFIG - summarize the system configuration

SummarizeConfig:

    if (-x analyze/summary) then
       analyze/summary

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CHECKDIR - check for missing directories

CheckDir:

    if ($CreateDirs == TRUE) then
       set Created = ""
       if ("$SYS_InstRoot" != "none") then
          if (!(-d $SYS_InstRoot/bin)) then
             mkdir -p $SYS_InstRoot/bin
             set Created = ( $Created $SYS_InstRoot/bin )
          endif
          if (!(-d $SYS_InstRoot/lib)) then
             mkdir -p $SYS_InstRoot/lib
             set Created = ( $Created $SYS_InstRoot/lib )
          endif
          if (!(-d $SYS_InstRoot/include)) then
             mkdir -p $SYS_InstRoot/include
             set Created = ( $Created $SYS_InstRoot/include )
          endif
          if (!(-d $SYS_InstRoot/$ScmDir)) then
             mkdir -p $SYS_InstRoot/$ScmDir
             set Created = ( $Created $SYS_InstRoot/$ScmDir )
          endif
          if (!(-d $SYS_InstRoot/$Man1Dir)) then
             mkdir -p $SYS_InstRoot/$Man1Dir
             set Created = ( $Created $SYS_InstRoot/$Man1Dir )
          endif
          if (!(-d $SYS_InstRoot/$Man3Dir)) then
             mkdir -p $SYS_InstRoot/$Man3Dir
             set Created = ( $Created $SYS_InstRoot/$Man3Dir )
          endif
       endif
       if ("$Created" != "") then
          echo ""
          echo "Directories:"
          foreach i ($Created)
             echo "   $i"
          end
          echo "have been created as requested"
          echo ""
       endif
    else
       set Missing = ""
       if ("$SYS_InstRoot" != "none") then
          if (!(-d $SYS_InstRoot/bin)) then
             set Missing = ( $Missing $SYS_InstRoot/bin )
          endif
          if (!(-d $SYS_InstRoot/lib)) then
             set Missing = ( $Missing $SYS_InstRoot/lib )
          endif
          if (!(-d $SYS_InstRoot/include)) then
             set Missing = ( $Missing $SYS_InstRoot/include )
          endif
          if (!(-d $SYS_InstRoot/$ScmDir)) then
             set Missing = ( $Missing $SYS_InstRoot/$ScmDir )
          endif
          if (!(-d $SYS_InstRoot/$Man1Dir)) then
             set Missing = ( $Missing $SYS_InstRoot/$Man1Dir )
          endif
          if (!(-d $SYS_InstRoot/$Man3Dir)) then
             set Missing = ( $Missing $SYS_InstRoot/$Man3Dir )
          endif
       endif
       if ("$Missing" != "") then
          echo ""
          echo "You have asked that PACT be installed in the following"
          echo "missing directories:"
          foreach i ($Missing)
             echo "   $i"
          end
          echo "You must either use the -c option to create these"
          echo "directories, choose another place to install PACT,"
          echo "or specify -i none for no installation"
          echo ""

          quit(2)
       endif
    endif

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# READCONFIG - read the user configuration file

ReadConfig:

    set lCfg = $args_[1]
    if ($#args_ > 1) then
       set lQuiet = $args_[2]
    else
       set lQuiet = FALSE
    endif

    Separator $Log
    if ($lQuiet == TRUE) then
       Note $Log ""
       Note $Log "Reading configuration file $lCfg"
    else
       NoteD $Log ""
       NoteD $Log "Reading configuration file $lCfg"
    endif
    Note  $Log ""
    flog  $Log cat $lCfg
    Note  $Log ""
    Separator $Log

    set nline  = `cat $lCfg | wc -l`
    set iline  = 1
    set CfgStk = ( $lCfg $iline $nline )

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# TOPLEVEL - loop over the input to define configuration parameters

while (1)

    call ReadLine()

    if ("$Line" == "") then
       continue
    else if ("$Line" == "++end++") then
       return
    endif

    set Key = $Line[1]
    if ($#Line < 3) then
       set Value = ""
    else
       set Value = `echo "$Line[3-]" | sed 's^ ^+sp+^g'`
    endif

    if ($#Line < 2) then
       set Oper = ""
    else
       set Oper = "$Line[2]"
    endif

    switch ("$Key")

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CCP - .c.i rule handler

   case ".c.i:":
        call ParseRule()

        flog $Log set CCP = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .c.i rule:\n$CCP"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CCOBJ - .c.o rule handler

   case ".c.o:":
        call ParseRule()

        flog $Log set CCObj = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .c.o rule:\n$CCObj"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CCARC - .c.a rule handler

   case ".c.a:":
        call ParseRule()

        flog $Log set CCArc = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .c.a rule:\n$CCArc"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# FCOBJ - .f.o rule handler

   case ".f.o:":
        call ParseRule()

        flog $Log set FCObj = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .f.o rule:\n$FCObj"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# FCARC - .f.a rule handler

   case ".f.a:":
        call ParseRule()

        flog $Log set FCArc = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .f.a rule:\n$FCArc"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# LEXOBJ - .l.o rule handler

   case ".l.o:":
        call ParseRule()

        flog $Log set LexObj = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.o rule:\n$LexObj"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# LEXARC - .l.a rule handler

   case ".l.a:":
        call ParseRule()

        flog $Log set LexArc = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.a rule:\n$LexArc"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# LEXC - .l.c rule handler

   case ".l.c:":
        call ParseRule()

        flog $Log set LexC = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.c rule:\n$LexC"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# YACCOBJ - .y.o rule handler

   case ".y.o:":
        call ParseRule()

        flog $Log set YaccObj = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.o rule:\n$YaccObj"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# YACCARC - .y.a rule handler

   case ".y.a:":
        call ParseRule()

        flog $Log set YaccArc = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.a rule:\n$YaccArc"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# YACCC - .y.c rule handler

   case ".y.c:":
        call ParseRule()

        flog $Log set YaccC = "$Val"
        if ($Verbose == "TRUE") then
           NoteD $Log "Redefining .l.c rule:\n$YaccC"
        endif

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# INCLUDE - handle include directives

   case include:

        set lfile = $Line[2]
        if (-f local/$lfile) then
           set lfile = local/$Line[2]
        else if (-f std/$lfile) then
           set lfile = std/$Line[2]
        else if (-f features/$lfile) then
           set lfile = features/$Line[2]
        else if (-f compilers/$lfile) then
           set lfile = compilers/$Line[2]
        endif

        set nline  = `cat $lfile | wc -l`
        set iline  = 1
        set CfgStk = ( $lfile $iline $nline $CfgStk )

        set ldepth = ""
        @ llen     = $#CfgStk
        @ llen     = $llen - 4
        while ($llen > 0)
           set ldepth = "   $ldepth"
           @ llen     = $llen - 4
        end

        Note $Log ""
        NoteD $Log "${ldepth}including $lfile"

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# RUN - handle run directives

   case run:

        @ nrun = $nrun + 1
        set lfile = $SYS_CfgDir/run.$nrun
        set cmd   = ( $Line[2-] )
        $cmd >&! $lfile

        set nline  = `cat $lfile | wc -l`
        set iline  = 1
        set CfgStk = ( $lfile $iline $nline $CfgStk )
        Note $Log "push $lfile"
        Note $Log "stack $CfgStk"
        flog $Log cat $lfile

        set ldepth = ""
        @ llen     = $#CfgStk
        @ llen     = $llen - 4
        while ($llen > 0)
           set ldepth = "   $ldepth"
           @ llen     = $llen - 4
        end

        Note $Log ""
        NoteD $Log "${ldepth}running $cmd"

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CDECLARATIONS - handle missing C declarations

   case CDeclarations:
        call CDeclare()

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# DPENVIRONMENT - handle definition of the distributed parallel environment

   case DPEnvironment:
        call DPDefine()

        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case SYS_InstRoot:
        if ($IBSet == "dflt") then
           flog $Log setenv SYS_InstRoot "$Value"
           flog $Log setenv PubInc       "-I$SYS_InstRoot/include"
           flog $Log setenv PubLib       "-L$SYS_InstRoot/lib"
        endif
        breaksw

   case NoExe:
	flog $Log setenv NoExe  TRUE
        flog $Log setenv Load   FALSE
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

   case define:
        Note $CEFile "#define $Line[2-]"
        breaksw

   case setenv:
        Note $SEFile "$Line[2-]"
        Note $Log $Line
        eval $Line[1] $Line[2] "$Line[3-]"
        breaksw

   case parent:
        set inf = ( `echo $Line[2-] | sed 's|(| |' | sed 's|)$||'` )
        set lvar = $inf[1]
        shift inf
        set lval = ( $inf )
        Note $SEFile "$lvar $lval"
        Note $Log $Line
        eval setenv $lvar "$lval"
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# STRUCT - handle struct syntax specifications

   case Tool:
        Note $Log "--- tool $Oper"
        flog $Log setenv CurrTool "$Oper"
        Note $Log "Defining tool $CurrTool"
        set tool = $CurrTool
        foreach i ($DefTools)
           if ("$i" != "$CurrTool") then
              set tool = ( $tool $i )
           endif
        end
        flog $Log set DefTools   = ( $tool )
        flog $Log set StructStack = ( $CurrTool $StructStack )
        breaksw

   case Group:
        Note $Log "--- group $Oper"
        flog $Log setenv CurrGrp "$Oper"
        set tgrp = $CurrGrp
        foreach i ($DefGroups)
           if ("$i" != "$CurrGrp") then
              set tgrp = ( $tgrp $i )
           endif
        end
        flog $Log set DefGroups  = ( $tgrp )
        flog $Log set StructStack = ( $CurrGrp $StructStack )
        breaksw

   case Use:
        call ProcessUse($Value, $Oper)
        breaksw

   case "}":
        flog $Log shift StructStack
        flog $Log setenv CurrGrp $StructStack[1]
        flog $Log setenv CurrTool ""
        Note $Log "--- end"
        breaksw

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# DEFAULT - the default case handler

   default:
       switch ("$Oper")
          case "=":
          case "+=":
          case "=+":
          case "-=":
          case "=?":
               call SetVar(TRUE, $Key, $Oper, "$Value")
               breaksw
          default:
               echo $Line >>& $STDOUT
               breaksw
       endsw
       breaksw

   endsw
end

#--------------------------------------------------------------------------

#                            SUBROUTINES

#--------------------------------------------------------------------------

# REPLACETEXT - do the required text replacement

ReplaceText:
    if ("$Replace" != "") then

       set TmpFile = file.tmp-$SYS_ID

       sed "$Replace" $STDOUT > $TmpFile
       ${RM} $STDOUT
       mv $TmpFile $STDOUT
    endif

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PRINTTEXT - do the required text printing with \n and \t handled
#           - properly (some csh's print them literally instead of the
#           - C way)

PrintText:
    if ("$Text" != "") then

       set STDAUX = tmp-$SYS_ID.1
       $RM $STDAUX

       echo "$Text" > $STDAUX
       grep "\\n" $STDAUX >>& /dev/null
       if ($status == 0) then
          (echo '1,$s/[\]t/	/g' ; echo '1,$s/[\]n//g' ; echo '1,$p') | ed - $STDAUX |\
          tr "\015" "\012" |\
          awk '($1 != "?") {print}' >>& $STDOUT
       else
          grep "\\t" $STDAUX >>& /dev/null
          if ($status == 0) then
             (echo '1,$s/[\]t/	/g' ; echo '1,$p') | ed - $STDAUX |\
             tr "\015" "\012" |\
             awk '($1 != "?") {print}' >>& $STDOUT
          else
             cat $STDAUX >>& $STDOUT
          endif
       endif

       $RM $STDAUX

    endif

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PARSERULE - read a rule into the Val register

ParseRule:

    if ($Trace == "TRUE") then
       NoteD $Log "Entering ParseRule"
    endif

    set Val = ""

ParseNextLine:

       call ReadLine()

       if (("$Line" == "") || ("$Line" == "++end++")) then
          if ($Trace == "TRUE") then
             NoteD $Log "Leaving ParseRule for $Return[1] with:\n $Val"
          endif

          return
       endif

       set Val = "$Val\t$Line\n"

    goto ParseNextLine

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# DPDEFINE - gather DP defines

DPDefine:

    if ($Trace == "TRUE") then
       NoteD $Log "Entering DPDefine"
    endif

    set STDOUT = "$DPFile"
    $RM $STDOUT
    touch $STDOUT

DPDefNextLine:

    call ReadLine()

    if (("$Line" == "end") || ("$Line" == "")) then
       if ($Trace == "TRUE") then
          NoteD $Log "Leaving DPDefine for $Return[1]"
       endif
    
       echo "" >>& $DPFile
    
       set STDOUT = "trash"
       return
    endif
    
    set Text = "setenv $Line"

    call PrintText()

    goto DPDefNextLine

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# CDECLARE - gather consecutive lines together for C declarations

CDeclare:

    if ($Trace == "TRUE") then
       NoteD $Log "Entering CDeclare"
    endif

    set STDOUT = "$CDFile"

CDeclNextLine:

    call ReadLine()

    if (("$Line" == "end") || ("$Line" == "")) then
       if ($Trace == "TRUE") then
          NoteD $Log "Leaving CDeclare for $Return[1]"
       endif
    
       echo "" >>& $CDFile
    
       set STDOUT = "trash"
       return
    endif
    
    set Text = "$Line"
    
    call PrintText()

    goto CDeclNextLine

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# PROCESSUSE - do all the variable settings implied by a Use specification

ProcessUse:

    set sg    = $args_[1]
    set loper = $args_[2]
    set whch  = ""

# determine whether or not it is a tool we are filling
    foreach t ($DefTools)
       if ($t == $sg) then
          set whch = tool
          break
       endif
    end

# determine whether or not it is a group we are filling
    foreach g ($DefGroups)
       if ($g == $sg) then
          set whch = group
          break
       endif
    end

    switch ($whch)

# fill out a group
       case group:
            Note $Log "Use group $sg to fill group $CurrGrp"
            foreach v ($lConfigVars)
               DEFD_VAR ${sg}_${v}
               if ("$ok" != "") then
                  VAR_VAL_SP ${sg} ${v}
                  if ($v == Exe) then
                     call SetVar(FALSE, ${v}, "=", "$value")
                  else
                     call SetVar(FALSE, ${v}, $loper, "$value")
                  endif
               endif
            end
            breaksw

# fill out a tool
       case tool:
            if ("$CurrTool" == "") then
               Note $Log "Use tool $sg to fill group $CurrGrp"
               foreach v ($lToolSpec)
                  DEFD_VAR ${sg}_${v}
                  if ("$ok" != "") then
                     VAR_VAL_SP ${sg} ${v}
                     call SetVar(FALSE, ${sg}_${v}, $loper, "$value")
                  endif
               end
            else
               Note $Log "Use tool $sg to fill tool $CurrTool"
               foreach v ($lToolSpec)
                  DEFD_VAR ${sg}_${v}
                  if ("$ok" != "") then
                     VAR_VAL_SP ${sg} ${v}
                     call SetVar(FALSE, ${v}, $loper, "$value")
                  endif
               end
            endif
            breaksw
    endsw
    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# READLINE - read the next line from the input

ReadLine:

    if ($Trace == "TRUE") then
       NoteD $Log "Entering ReadLine"
    endif

    set ok = FALSE
    while ($#CfgStk > 0)
       set lfile = $CfgStk[1]
       @   iline = $CfgStk[2]
       @   nline = $CfgStk[3]
       shift CfgStk
       shift CfgStk
       shift CfgStk
       if ($iline <= $nline) then
          set ok = TRUE
          break
       endif
    end

    if ($ok == TRUE) then
       get_line Line $lfile $iline
#       set Line  = `head -n $iline $lfile | tail -n 1`
       @   iline = $iline + 1

       set CfgStk = ( $lfile $iline $nline $CfgStk )

# toss blank and comment lines
       if (($#Line < 1) || (`expr "$Line" : "#"` > 0)) then
          if ($Verbose == "TRUE") then
             NoteD $Log "${lfile}[$iline/$nline] ignored: $Line"
          endif
          set Line = ""
       endif
    else
       set Line = "++end++"
       Note $Log ""
    endif

    if ($Trace == "TRUE") then
       NoteD $Log "Leaving ReadLine with $Line"
    endif

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# SETVAR - set a variable as directed

SetVar:

    set lrep  = $args_[1]
    set lvar  = $args_[2]
    set loper = $args_[3]
    shift args_
    shift args_
    shift args_

    set prfx = $StructStack[1]

# attach the current group suffix
    if ($prfx == "Glb") then
       setenv Globals "$Globals $lvar"
       set fvar = $lvar
    else
       set fvar = ${prfx}_$lvar
    endif

    set lval = ( `echo "$args_" | sed 's^+sp+^ ^g'` )

    switch ("$loper")
       case "+=":
       case "=+":
            (eval 'echo $'$fvar) >>& /dev/null
            if ($status != 0) then
               Note $Log "Variable $fvar does not exist changing $loper to ="
               set loper = "="
            endif            
            breaksw
       default
            breaksw
    endsw

    switch ("$loper")

# set variable
       case "=":
            (eval "echo ${lval}") >>& /dev/null
            if ($status == 0) then
               set nval = ( `eval "echo $lval"` )
               if ($lrep == TRUE) then
                  echo "$fvar = $nval" >>& $MVFile
               endif
               if ($#nval == 1) then
                  Note $Log "setenv $fvar $nval"
                  eval "setenv $fvar $nval"
               else
                  Note $Log "setenv $fvar "'"'$nval'"'
                  eval "setenv $fvar "'"'$nval'"'
               endif
            else
               set nval = ""
               Note $Log "setenv $fvar $nval"
               eval "setenv $fvar $nval"
            endif
            breaksw

# add item to beginning of the existing variable
       case "+=":

# check value of lval
# we want things such as "foo += $bar" to do nothing if
# "$bar" is not defined
            (eval "echo ${lval}") >>& /dev/null
            if ($status == 0) then
               set lval = `eval "echo ${lval}"`
               set nval = `eval 'echo $'$fvar`
               Note $Log "Change    |$fvar|"
               Note $Log "Add       |$lval|"
               Note $Log "Old value |$nval|"

               set nval = ( $lval $nval )
               Note $Log "New value |$nval|"

               set lexpr = ( "setenv $fvar "'"'$nval'"' )
               Note $Log "Change expression |$lexpr|"
               eval $lexpr
            else
               Note $Log "   += not changing $fvar - no value for |${lval}|"
            endif
            breaksw

# add item to end of the existing variable
       case "=+":

# check value of lval
# we want things such as "foo =+ $bar" to do nothing if
# "$bar" is not defined
            (eval "echo ${lval}") >>& /dev/null
            if ($status == 0) then
               set lval = `eval "echo ${lval}"`
               set nval = `eval 'echo $'$fvar`
               Note $Log "Change    |$fvar|"
               Note $Log "Add       |$lval|"
               Note $Log "Old value |$nval|"

               set nval = ( $nval $lval )
               Note $Log "New value |$nval|"

               set lexpr = ( "setenv $fvar "'"'$nval'"' )
               Note $Log "Change expression |$lexpr|"
               eval $lexpr
            else
               Note $Log "   =+ not changing $fvar - no value for |${lval}|"
            endif
            breaksw

# remove literal item from variable
       case "-=":
            set nval = `eval 'echo $'$fvar`
            Note $Log "Change    |$fvar|"
            Note $Log "Remove    |$lval|"
            Note $Log "Old value |$nval|"

            set nval = `echo $nval | sed 's|'$lval'||'`
            Note $Log "New value |$nval|"

	    set lexpr = ( "setenv $fvar "'"'$nval'"' )
            Note $Log "Change expression |$lexpr|"
            eval $lexpr
            breaksw

# set value only if undefined
       case "=?":

# check value of lval
# we want things such as "foo =? $bar" to do nothing if
# "$bar" is not defined
            (eval "echo ${lval}") >>& /dev/null
            if ($status == 0) then
               set nval = ( `eval "echo $lval"` )
               if ($#nval == 1) then
                  Note $Log "setenv $fvar $nval"
                  eval "setenv $fvar $nval"
               else
                  Note $Log "setenv $fvar "'"'$nval'"'
                  eval "setenv $fvar "'"'$nval'"'
               endif
            else
               Note $Log "   =? not changing $fvar - no value for |${lval}|"
            endif           
            breaksw

       default:
            echo "Bad operator '"$loper"' in SETVAR"
            breaksw
    endsw

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# UNIQUE - remove duplicate tokens from a list

Unique:

    set NewULst = ""

    while ($#ULst > 0)
       set i = $ULst[1]
       shift ULst
       set ok = TRUE
       foreach j ($NewULst)
          if ("$i" == "$j") then
             set ok = FALSE
             break
          endif
       end
       if ($ok == TRUE) then
          set NewULst = ( $NewULst $i )
       endif
    end

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

# FINISH - complete the configuration files

Finish:

# these are finally determined by now and it is safe to define them
    setenv IncDir  $SYS_Root/include
    setenv LibDir  $SYS_Root/lib
    setenv BinDir  $SYS_Root/bin
    setenv SchDir  $SYS_Root/scheme

    NoteD $Log "Writing system dependent files"

# if T3D, fiddle pdb fortran interface regression test source
    if ("$PFE" == "mppexec") then
       cd $SYS_Base/pdb

       set STDAUX = tmp-$SYS_ID.f
       flog $Log $RM $STDAUX
       sed -e s/'iarg, iargc'/'iarg, ipxfargc, ilen, ierror'/              \
           -e s/'iargc()'/'ipxfargc()'/                                    \
           -e s/'getarg(iarg, arg)'/'pxfgetarg(iarg, arg, ilen, ierror)'/g \
           pdftst.f > $STDAUX
       flog $Log ${RM} pdftst.f
       flog $Log mv $STDAUX pdftst.f
       flog $Log cd $SYS_MngDir
    endif

# remove duplicate tokens in selected lists
    set ULst = ($MDG_Inc)
    call Unique()
    setenv MDG_Inc "$NewULst"

    set ULst = ($CC_Inc)
    call Unique()
    setenv CC_Inc "$NewULst"

    set ULst = ($MDG_Lib)
    call Unique()
    setenv MDG_Lib "$NewULst"

    set ULst = ($LD_Lib)
    call Unique()
    setenv LD_Lib "$NewULst"

    setenv DefGroups  "$DefGroups"
    setenv ConfigVars "$lConfigVars"

    setenv CCP        "$CCP"
    setenv CCObj      "$CCObj"
    setenv CCArc      "$CCArc"
    setenv LexObj     "$LexObj"
    setenv LexArc     "$LexArc"
    setenv LexC       "$LexC"
    setenv YaccObj    "$YaccObj"
    setenv YaccArc    "$YaccArc"
    setenv YaccC      "$YaccC"
    setenv FCObj      "$FCObj"
    setenv FCArc      "$FCArc"

# write the configuration generated files for PACT
    write/envf TRUE
    write/package
    write/configured $CONFIG_FILE
    write/f90-interface
    write/make-def
    write/make-macros
    write/makefile
    write/iso-c.h
    write/scconfig.h
    write/scdecls.h
    write/syntax.h

    if (-d $SYS_Base/sx/applications) then
       write/spokes.scm
    endif

    write/install-pact

    write/smake

    flog $Log $RMDir $SYS_CfgDir

    flog $Log unset noglob

    return

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------

